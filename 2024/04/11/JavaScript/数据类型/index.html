<!DOCTYPE html><html lang="en" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0,viewport-fit=cover"><title>QingYv | QingYv</title><meta name="author" content="John Doe"><meta name="copyright" content="John Doe"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="[TOC] 原始类型的方法一个原始值：  是原始类型中的一种值。 在 JavaScript 中有 7 种原始类型：string，number，bigint，boolean，symbol，null 和 undefined。  一个对象：  能够存储多个值作为属性。 可以使用大括号 &#123;&#125; 创建对象，例如：&#123;name: &quot;John&quot;, age: 30&amp;#">
<meta property="og:type" content="article">
<meta property="og:title" content="QingYv">
<meta property="og:url" content="http://example.com/2024/04/11/JavaScript/%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B/index.html">
<meta property="og:site_name" content="QingYv">
<meta property="og:description" content="[TOC] 原始类型的方法一个原始值：  是原始类型中的一种值。 在 JavaScript 中有 7 种原始类型：string，number，bigint，boolean，symbol，null 和 undefined。  一个对象：  能够存储多个值作为属性。 可以使用大括号 &#123;&#125; 创建对象，例如：&#123;name: &quot;John&quot;, age: 30&amp;#">
<meta property="og:locale" content="en_US">
<meta property="og:image" content="https://i.loli.net/2021/02/24/5O1day2nriDzjSu.png">
<meta property="article:published_time" content="2024-04-11T13:15:28.206Z">
<meta property="article:modified_time" content="2024-04-14T14:45:48.836Z">
<meta property="article:author" content="John Doe">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://i.loli.net/2021/02/24/5O1day2nriDzjSu.png"><link rel="shortcut icon" href="/img/favicon.png"><link rel="canonical" href="http://example.com/2024/04/11/JavaScript/%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B/index.html"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><link rel="stylesheet" href="/css/index.css?v=4.13.0"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@6.5.1/css/all.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/ui@5.0.33/dist/fancybox/fancybox.min.css" media="print" onload="this.media='all'"><script>const GLOBAL_CONFIG = {
  root: '/',
  algolia: undefined,
  localSearch: undefined,
  translate: undefined,
  noticeOutdate: undefined,
  highlight: {"plugin":"highlight.js","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":false},
  copy: {
    success: 'Copy Successful',
    error: 'Copy Error',
    noSupport: 'Browser Not Supported'
  },
  relativeDate: {
    homepage: false,
    post: false
  },
  runtime: '',
  dateSuffix: {
    just: 'Just now',
    min: 'minutes ago',
    hour: 'hours ago',
    day: 'days ago',
    month: 'months ago'
  },
  copyright: undefined,
  lightbox: 'fancybox',
  Snackbar: undefined,
  infinitegrid: {
    js: 'https://cdn.jsdelivr.net/npm/@egjs/infinitegrid@4.11.1/dist/infinitegrid.min.js',
    buttonText: 'Load More'
  },
  isPhotoFigcaption: false,
  islazyload: false,
  isAnchor: false,
  percent: {
    toc: true,
    rightside: false,
  },
  autoDarkmode: false
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: 'QingYv',
  isPost: true,
  isHome: false,
  isHighlightShrink: false,
  isToc: true,
  postUpdate: '2024-04-14 22:45:48'
}</script><script>(win=>{
      win.saveToLocal = {
        set: (key, value, ttl) => {
          if (ttl === 0) return
          const now = Date.now()
          const expiry = now + ttl * 86400000
          const item = {
            value,
            expiry
          }
          localStorage.setItem(key, JSON.stringify(item))
        },
      
        get: key => {
          const itemStr = localStorage.getItem(key)
      
          if (!itemStr) {
            return undefined
          }
          const item = JSON.parse(itemStr)
          const now = Date.now()
      
          if (now > item.expiry) {
            localStorage.removeItem(key)
            return undefined
          }
          return item.value
        }
      }
    
      win.getScript = (url, attr = {}) => new Promise((resolve, reject) => {
        const script = document.createElement('script')
        script.src = url
        script.async = true
        script.onerror = reject
        script.onload = script.onreadystatechange = function() {
          const loadState = this.readyState
          if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
          script.onload = script.onreadystatechange = null
          resolve()
        }

        Object.keys(attr).forEach(key => {
          script.setAttribute(key, attr[key])
        })

        document.head.appendChild(script)
      })
    
      win.getCSS = (url, id = false) => new Promise((resolve, reject) => {
        const link = document.createElement('link')
        link.rel = 'stylesheet'
        link.href = url
        if (id) link.id = id
        link.onerror = reject
        link.onload = link.onreadystatechange = function() {
          const loadState = this.readyState
          if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
          link.onload = link.onreadystatechange = null
          resolve()
        }
        document.head.appendChild(link)
      })
    
      win.activateDarkMode = () => {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      win.activateLightMode = () => {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
        }
      }
      const t = saveToLocal.get('theme')
    
        if (t === 'dark') activateDarkMode()
        else if (t === 'light') activateLightMode()
      
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        if (asideStatus === 'hide') {
          document.documentElement.classList.add('hide-aside')
        } else {
          document.documentElement.classList.remove('hide-aside')
        }
      }
    
      const detectApple = () => {
        if(/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)){
          document.documentElement.classList.add('apple')
        }
      }
      detectApple()
    })(window)</script><meta name="generator" content="Hexo 7.2.0"></head><body><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img is-center"><img src="https://i.loli.net/2021/02/24/5O1day2nriDzjSu.png" onerror="onerror=null;src='/img/friend_404.gif'" alt="avatar"/></div><div class="sidebar-site-data site-data is-center"><a href="/archives/"><div class="headline">Articles</div><div class="length-num">18</div></a><a href="/tags/"><div class="headline">Tags</div><div class="length-num">0</div></a><a href="/categories/"><div class="headline">Categories</div><div class="length-num">0</div></a></div><hr class="custom-hr"/></div></div><div class="post" id="body-wrap"><header class="post-bg" id="page-header"><nav id="nav"><span id="blog-info"><a href="/" title="QingYv"><span class="site-name">QingYv</span></a></span><div id="menus"><div id="toggle-menu"><a class="site-page" href="javascript:void(0);"><i class="fas fa-bars fa-fw"></i></a></div></div></nav><div id="post-info"><h1 class="post-title">Untitled</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">Created</span><time class="post-meta-date-created" datetime="2024-04-11T13:15:28.206Z" title="Created 2024-04-11 21:15:28">2024-04-11</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">Updated</span><time class="post-meta-date-updated" datetime="2024-04-14T14:45:48.836Z" title="Updated 2024-04-14 22:45:48">2024-04-14</time></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-pv-cv" id="" data-flag-title=""><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">Post Views:</span><span id="busuanzi_value_page_pv"><i class="fa-solid fa-spinner fa-spin"></i></span></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="post-content" id="article-container"><p>[TOC]</p>
<h1 id="原始类型的方法"><a href="#原始类型的方法" class="headerlink" title="原始类型的方法"></a>原始类型的方法</h1><p>一个原始值：</p>
<ul>
<li>是原始类型中的一种值。</li>
<li>在 JavaScript 中有 7 种原始类型：<code>string</code>，<code>number</code>，<code>bigint</code>，<code>boolean</code>，<code>symbol</code>，<code>null</code> 和 <code>undefined</code>。</li>
</ul>
<p>一个对象：</p>
<ul>
<li>能够存储多个值作为属性。</li>
<li>可以使用大括号 <code>&#123;&#125;</code> 创建对象，例如：<code>&#123;name: &quot;John&quot;, age: 30&#125;</code>。JavaScript 中还有其他种类的对象，例如函数就是对象。</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">str.<span class="title function_">toUpperCase</span>();</span><br><span class="line">n.<span class="title function_">toFixed</span>(<span class="number">2</span>);</span><br></pre></td></tr></table></figure>

<p><strong>构造器 <code>String/Number/Boolean</code> 仅供内部使用</strong></p>
<h1 id="数字类型"><a href="#数字类型" class="headerlink" title="数字类型"></a>数字类型</h1><p>在现代 JavaScript 中，数字（number）有两种类型：</p>
<ol>
<li>JavaScript 中的常规数字以 64 位的格式 <a target="_blank" rel="noopener" href="https://en.wikipedia.org/wiki/IEEE_754">IEEE-754</a> 存储，也被称为“双精度浮点数”。这是我们大多数时候所使用的数字，我们将在本章中学习它们。</li>
<li>BigInt 用于表示任意长度的整数。有时会需要它们，因为正如我们在前面的章节 <a target="_blank" rel="noopener" href="https://zh.javascript.info/types">数据类型</a> 中提到的，常规整数不能安全地超过 <code>(253-1)</code> 或小于 <code>-(253-1)</code>。由于仅在少数特殊领域才会用到 BigInt，因此我们在特殊的章节 <a target="_blank" rel="noopener" href="https://zh.javascript.info/bigint">BigInt</a> 中对其进行了介绍。</li>
</ol>
<p>十六进制：0x，二进制0b，八进制0o</p>
<h2 id="toString-base"><a href="#toString-base" class="headerlink" title="toString(base)"></a><a target="_blank" rel="noopener" href="https://zh.javascript.info/number#tostringbase">toString(base)</a></h2><p>方法 <code>num.toString(base)</code> 返回在给定 <code>base</code> 进制数字系统中 <code>num</code> 的字符串表示形式。<code>base</code> 的范围可以从 <code>2</code> 到 <code>36</code>。默认情况下是 <code>10</code>。</p>
<p>常见的用例如下：</p>
<ul>
<li><strong>base&#x3D;16</strong> 用于十六进制颜色，字符编码等，数字可以是 <code>0..9</code> 或 <code>A..F</code>。</li>
<li><strong>base&#x3D;2</strong> 主要用于调试按位操作，数字可以是 <code>0</code> 或 <code>1</code>。</li>
<li><strong>base&#x3D;36</strong> 是最大进制，数字可以是 <code>0..9</code> 或 <code>A..Z</code>。所有拉丁字母都被用于了表示数字。对于 <code>36</code> 进制来说，一个有趣且有用的例子是，当我们需要将一个较长的数字标识符转换成较短的时候，例如做一个短的 URL。</li>
</ul>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="title function_">alert</span>( <span class="number">123456.</span>.<span class="title function_">toString</span>(<span class="number">36</span>) ); <span class="comment">// 2n9c</span></span><br><span class="line"> (<span class="number">123456</span>).<span class="title function_">toString</span>(<span class="number">36</span>)</span><br></pre></td></tr></table></figure>

<p><strong>使用两个点来调用一个方法</strong></p>
<p>请注意 <code>123456..toString(36)</code> 中的两个点不是打错了。如果我们想直接在一个数字上调用一个方法，比如上面例子中的 <code>toString</code>，那么我们需要在它后面放置两个点 <code>..</code>。</p>
<h2 id="舍入"><a href="#舍入" class="headerlink" title="舍入"></a><a target="_blank" rel="noopener" href="https://zh.javascript.info/number#she-ru">舍入</a></h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Math.floor</span><br></pre></td></tr></table></figure>

<p>向下舍入：<code>3.1</code> 变成 <code>3</code>，<code>-1.1</code> 变成 <code>-2</code>。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Math.ceil</span><br></pre></td></tr></table></figure>

<p>向上舍入：<code>3.1</code> 变成 <code>4</code>，<code>-1.1</code> 变成 <code>-1</code>。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Math.round</span><br></pre></td></tr></table></figure>

<p>向最近的整数舍入：<code>3.1</code> 变成 <code>3</code>，<code>3.6</code> 变成 <code>4</code>，中间值 <code>3.5</code> 变成 <code>4</code>。</p>
<p><code>Math.trunc</code>（IE 浏览器不支持这个方法）</p>
<p>移除小数点后的所有内容而没有舍入：<code>3.1</code> 变成 <code>3</code>，<code>-1.1</code> 变成 <code>-1</code>。</p>
<p> <code>toFixed</code> 的结果是一个字符串。如果小数部分比所需要的短，则在结尾添加零。可以使用一元加号或 <code>Number()</code> 调用，将其转换为数字，例如 <code>+ num.toFixed(5)</code>。</p>
<h2 id="不精确的计算"><a href="#不精确的计算" class="headerlink" title="不精确的计算"></a><a target="_blank" rel="noopener" href="https://zh.javascript.info/number#bu-jing-que-de-ji-suan">不精确的计算</a></h2><p>如果一个数字真的很大，则可能会溢出 64 位存储，变成一个特殊的数值 <code>Infinity</code>。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="title function_">alert</span>( <span class="number">0.1</span> + <span class="number">0.2</span> == <span class="number">0.3</span> ); <span class="comment">// false</span></span><br></pre></td></tr></table></figure>

<p>最可靠的方法是借助方法 <a target="_blank" rel="noopener" href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Number/toFixed">toFixed(n)</a> 对结果进行舍入。</p>
<p>可以将数字临时乘以 100（或更大的数字），将其转换为整数，进行数学运算，然后再除回。当我们使用整数进行数学运算时，误差会有所减少。</p>
<h2 id="测试：isFinite-和-isNaN"><a href="#测试：isFinite-和-isNaN" class="headerlink" title="测试：isFinite 和 isNaN"></a><a target="_blank" rel="noopener" href="https://zh.javascript.info/number#ce-shi-isfinite-he-isnan">测试：isFinite 和 isNaN</a></h2><ul>
<li><code>Infinity</code>（和 <code>-Infinity</code>）是一个特殊的数值，比任何数值都大（小）。</li>
<li><code>NaN</code> 代表一个 error。</li>
<li><code>isNaN(value)</code> 将其参数转换为数字，然后测试它是否为 <code>NaN</code></li>
<li><code>isFinite(value)</code> 将其参数转换为数字，如果是常规数字而不是 <code>NaN/Infinity/-Infinity</code>，则返回 <code>true</code>。在所有数字函数中，包括 <code>isFinite</code>，空字符串或仅有空格的字符串均被视为 <code>0</code>。</li>
</ul>
<p><strong>与 <code>Object.is</code> 进行比较</strong></p>
<p>有一个特殊的内建方法 <code>Object.is</code>，它类似于 <code>===</code> 一样对值进行比较，但它对于两种边缘情况更可靠：</p>
<ol>
<li>它适用于 <code>NaN</code>：<code>Object.is(NaN, NaN) === true</code>，这是件好事。</li>
<li>值 <code>0</code> 和 <code>-0</code> 是不同的：<code>Object.is(0, -0) === false</code>，从技术上讲这是对的，因为在内部，数字的符号位可能会不同，即使其他所有位均为零。</li>
</ol>
<p>在所有其他情况下，<code>Object.is(a, b)</code> 与 <code>a === b</code> 相同。</p>
<p>这种比较方式经常被用在 JavaScript 规范中。当内部算法需要比较两个值是否完全相同时，它使用 <code>Object.is</code>。内部称为 <a target="_blank" rel="noopener" href="https://tc39.github.io/ecma262/#sec-samevalue">SameValue</a>。</p>
<h2 id="parseInt-和-parseFloat"><a href="#parseInt-和-parseFloat" class="headerlink" title="parseInt 和 parseFloat"></a><a target="_blank" rel="noopener" href="https://zh.javascript.info/number#parseint-he-parsefloat">parseInt 和 parseFloat</a></h2><p>从字符串中“读取”数字，直到无法读取为止。如果发生 error，则返回收集到的数字。函数 <code>parseInt</code>返回一个整数，而 <code>parseFloat</code> 返回一个浮点数。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="title function_">alert</span>( <span class="built_in">parseInt</span>(<span class="string">&#x27;100px&#x27;</span>) ); <span class="comment">// 100</span></span><br><span class="line"><span class="title function_">alert</span>( <span class="built_in">parseFloat</span>(<span class="string">&#x27;12.5em&#x27;</span>) ); <span class="comment">// 12.5</span></span><br><span class="line"></span><br><span class="line"><span class="title function_">alert</span>( <span class="built_in">parseInt</span>(<span class="string">&#x27;12.3&#x27;</span>) ); <span class="comment">// 12，只有整数部分被返回了</span></span><br><span class="line"><span class="title function_">alert</span>( <span class="built_in">parseFloat</span>(<span class="string">&#x27;12.3.4&#x27;</span>) ); <span class="comment">// 12.3，在第二个点出停止了读取</span></span><br></pre></td></tr></table></figure>

<p><code>parseInt/parseFloat</code> 会返回 <code>NaN</code>。当没有数字可读时会发生这种情况：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="title function_">alert</span>( <span class="built_in">parseInt</span>(<span class="string">&#x27;a123&#x27;</span>) ); <span class="comment">// NaN，第一个符号停止了读取</span></span><br></pre></td></tr></table></figure>

<p><strong>parseInt(str, radix) 的第二个参数</strong></p>
<p><code>parseInt()</code> 函数具有可选的第二个参数。它指定了数字系统的基数，因此 <code>parseInt</code> 还可以解析十六进制数字、二进制数字等的字符串。</p>
<h2 id="其他数学函数"><a href="#其他数学函数" class="headerlink" title="其他数学函数"></a><a target="_blank" rel="noopener" href="https://zh.javascript.info/number#qi-ta-shu-xue-han-shu">其他数学函数</a></h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Math.random()</span><br></pre></td></tr></table></figure>

<p>返回一个从 0 到 1 的随机数（不包括 1）。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Math.max(a, b, c...)` 和 `Math.min(a, b, c...)</span><br></pre></td></tr></table></figure>

<p>从任意数量的参数中返回最大值和最小值.</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Math.pow(n, power)</span><br></pre></td></tr></table></figure>

<p>返回 <code>n</code> 的给定（power）次幂。</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a><a target="_blank" rel="noopener" href="https://zh.javascript.info/number#zong-jie">总结</a></h2><p>要写有很多零的数字：</p>
<ul>
<li>将 <code>&quot;e&quot;</code> 和 0 的数量附加到数字后。就像：<code>123e6</code> 与 <code>123</code> 后面接 6 个 0 相同。</li>
<li><code>&quot;e&quot;</code> 后面的负数将使数字除以 1 后面接着给定数量的零的数字。例如 <code>123e-6</code> 表示 <code>0.000123</code>（<code>123</code> 的百万分之一）。</li>
</ul>
<p>对于不同的数字系统：</p>
<ul>
<li>可以直接在十六进制（<code>0x</code>），八进制（<code>0o</code>）和二进制（<code>0b</code>）系统中写入数字。</li>
<li><code>parseInt(str, base)</code> 将字符串 <code>str</code> 解析为在给定的 <code>base</code> 数字系统中的整数，<code>2 ≤ base ≤ 36</code>。</li>
<li><code>num.toString(base)</code> 将数字转换为在给定的 <code>base</code> 数字系统中的字符串。</li>
</ul>
<p>对于常规数字检测：</p>
<ul>
<li><code>isNaN(value)</code> 将其参数转换为数字，然后检测它是否为 <code>NaN</code></li>
<li><code>isFinite(value)</code> 将其参数转换为数字，如果它是常规数字，则返回 <code>true</code>，而不是 <code>NaN/Infinity/-Infinity</code></li>
</ul>
<p>要将 <code>12pt</code> 和 <code>100px</code> 之类的值转换为数字：</p>
<ul>
<li>使用 <code>parseInt/parseFloat</code> 进行“软”转换，它从字符串中读取数字，然后返回在发生 error 前可以读取到的值。</li>
</ul>
<p>小数：</p>
<ul>
<li>使用 <code>Math.floor</code>，<code>Math.ceil</code>，<code>Math.trunc</code>，<code>Math.round</code> 或 <code>num.toFixed(precision)</code> 进行舍入。</li>
<li>请确保记住使用小数时会损失精度。</li>
</ul>
<p>更多数学函数：</p>
<ul>
<li>需要时请查看 <a target="_blank" rel="noopener" href="https://developer.mozilla.org/en/docs/Web/JavaScript/Reference/Global_Objects/Math">Math</a> 对象。这个库很小，但是可以满足基本的需求。</li>
</ul>
<h1 id="字符串"><a href="#字符串" class="headerlink" title="字符串"></a>字符串</h1><p>使用反引号允许通过 <code>$&#123;…&#125;</code> 将任何表达式嵌入到字符串中，另一个优点是允许字符串跨行</p>
<h2 id="字符串长度"><a href="#字符串长度" class="headerlink" title="字符串长度"></a><a target="_blank" rel="noopener" href="https://zh.javascript.info/string#zi-fu-chuan-chang-du">字符串长度</a></h2><p><code>length</code> 属性表示字符串长度，<code>length</code> <strong>是一个属性</strong>，不需要加括号。</p>
<h2 id="访问字符"><a href="#访问字符" class="headerlink" title="访问字符"></a><a target="_blank" rel="noopener" href="https://zh.javascript.info/string#fang-wen-zi-fu">访问字符</a></h2><p>要获取在 <code>pos</code> 位置的一个字符，可以使用方括号 <code>[pos]</code> 或者调用 <a target="_blank" rel="noopener" href="https://developer.mozilla.org/zh/docs/Web/JavaScript/Reference/Global_Objects/String/charAt">str.charAt(pos)</a> 方法。第一个字符从零位置开始.</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> str = <span class="string">&#x27;Hello&#x27;</span>;</span><br><span class="line"><span class="title function_">alert</span>( str[<span class="number">0</span>] );</span><br><span class="line"><span class="title function_">alert</span>( str.<span class="title function_">charAt</span>(<span class="number">0</span>) );</span><br><span class="line"><span class="title function_">alert</span>( str.<span class="title function_">charAt</span>(str.<span class="property">length</span> - <span class="number">1</span>) );</span><br></pre></td></tr></table></figure>

<p>如果没有找到字符，<code>[]</code> 返回 <code>undefined</code>，而 <code>charAt</code> 返回一个空字符串</p>
<p>使用 <code>for..of</code> 遍历字符</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> char <span class="keyword">of</span> <span class="string">&quot;Hello&quot;</span>) &#123;</span><br><span class="line">  <span class="title function_">alert</span>(char); <span class="comment">// H,e,l,l,o（char 变为 &quot;H&quot;，然后是 &quot;e&quot;，然后是 &quot;l&quot; 等）</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="字符串是不可变的"><a href="#字符串是不可变的" class="headerlink" title="字符串是不可变的"></a><a target="_blank" rel="noopener" href="https://zh.javascript.info/string#zi-fu-chuan-shi-bu-ke-bian-de">字符串是不可变的</a></h2><p>在 JavaScript 中，字符串不可更改。改变字符是不可能的。</p>
<h2 id="改变大小写"><a href="#改变大小写" class="headerlink" title="改变大小写"></a><a target="_blank" rel="noopener" href="https://zh.javascript.info/string#gai-bian-da-xiao-xie">改变大小写</a></h2><p><a target="_blank" rel="noopener" href="https://developer.mozilla.org/zh/docs/Web/JavaScript/Reference/Global_Objects/String/toLowerCase">toLowerCase()</a> 和 <a target="_blank" rel="noopener" href="https://developer.mozilla.org/zh/docs/Web/JavaScript/Reference/Global_Objects/String/toUpperCase">toUpperCase()</a> 方法可以改变大小写</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="title function_">alert</span>( <span class="string">&#x27;Interface&#x27;</span>.<span class="title function_">toUpperCase</span>() ); <span class="comment">// INTERFACE</span></span><br><span class="line"><span class="title function_">alert</span>( <span class="string">&#x27;Interface&#x27;</span>.<span class="title function_">toLowerCase</span>() ); <span class="comment">// interface</span></span><br><span class="line"><span class="title function_">alert</span>( <span class="string">&#x27;Interface&#x27;</span>[<span class="number">0</span>].<span class="title function_">toLowerCase</span>() ); <span class="comment">// &#x27;i&#x27;</span></span><br></pre></td></tr></table></figure>

<h2 id="查找子字符串"><a href="#查找子字符串" class="headerlink" title="查找子字符串"></a><a target="_blank" rel="noopener" href="https://zh.javascript.info/string#cha-zhao-zi-zi-fu-chuan">查找子字符串</a></h2><h3 id="str-indexOf"><a href="#str-indexOf" class="headerlink" title="str.indexOf"></a><a target="_blank" rel="noopener" href="https://zh.javascript.info/string#strindexof">str.indexOf</a></h3><p>第一个方法是 <a target="_blank" rel="noopener" href="https://developer.mozilla.org/zh/docs/Web/JavaScript/Reference/Global_Objects/String/indexOf">str.indexOf(substr, pos)</a>。</p>
<p>它从给定位置 <code>pos</code> 开始，在 <code>str</code> 中查找 <code>substr</code>，如果没有找到，则返回 <code>-1</code>，否则返回匹配成功的位置。</p>
<p>可选的第二个参数允许我们从一个给定的位置开始检索</p>
<p>如果对所有存在位置都感兴趣，可以在一个循环中使用 <code>indexOf</code>。每一次新的调用都发生在上一匹配位置之后</p>
<p><strong><code>str.lastIndexOf(substr, pos)</code></strong></p>
<p>还有一个类似的方法 <a target="_blank" rel="noopener" href="https://developer.mozilla.org/zh/docs/Web/JavaScript/Reference/Global_Objects/String/lastIndexOf">str.lastIndexOf(substr, position)</a>，它从字符串的末尾开始搜索到开头。它会以相反的顺序列出这些事件。</p>
<h4 id="按位（bitwise）NOT-技巧"><a href="#按位（bitwise）NOT-技巧" class="headerlink" title="按位（bitwise）NOT 技巧"></a><a target="_blank" rel="noopener" href="https://zh.javascript.info/string#an-wei-bitwisenot-ji-qiao">按位（bitwise）NOT 技巧</a></h4><p>它将数字转换为 32-bit 整数（如果存在小数部分，则删除小数部分），然后对其二进制表示形式中的所有位均取反。对于 32-bit 整数，<code>~n</code> 等于 <code>-(n+1)</code>。</p>
<p>只有当 <code>n == -1</code> 时，<code>~n</code> 才为零（适用于任何 32-bit 带符号的整数 <code>n</code>）。</p>
<p>仅当 <code>indexOf</code> 的结果不是 <code>-1</code> 时，检查 <code>if ( ~str.indexOf(&quot;...&quot;) )</code> 才为真。</p>
<h3 id="includes，startsWith，endsWith"><a href="#includes，startsWith，endsWith" class="headerlink" title="includes，startsWith，endsWith"></a><a target="_blank" rel="noopener" href="https://zh.javascript.info/string#includesstartswithendswith">includes，startsWith，endsWith</a></h3><p> <a target="_blank" rel="noopener" href="https://developer.mozilla.org/zh/docs/Web/JavaScript/Reference/Global_Objects/String/includes">str.includes(substr, pos)</a> 根据 <code>str</code> 中是否包含 <code>substr</code> 来返回 <code>true/false</code>。</p>
<p>方法 <a target="_blank" rel="noopener" href="https://developer.mozilla.org/zh/docs/Web/JavaScript/Reference/Global_Objects/String/startsWith">str.startsWith()</a> 和 <a target="_blank" rel="noopener" href="https://developer.mozilla.org/zh/docs/Web/JavaScript/Reference/Global_Objects/String/endsWith">str.endsWith()</a> 的功能与其名称所表示的意思相同，返回true&#x2F;false</p>
<h2 id="获取子字符串"><a href="#获取子字符串" class="headerlink" title="获取子字符串"></a><a target="_blank" rel="noopener" href="https://zh.javascript.info/string#huo-qu-zi-zi-fu-chuan">获取子字符串</a></h2><p>三种获取字符串的方法：<code>substring</code>、<code>substr</code> 和 <code>slice</code>。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">str.<span class="title function_">slice</span>(start [, end])</span><br></pre></td></tr></table></figure>

<p>返回字符串从 <code>start</code> 到（但不包括）<code>end</code> 的部分。如果没有第二个参数，<code>slice</code> 会一直运行到字符串末尾</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">str.substring(start [, end])</span><br></pre></td></tr></table></figure>

<p>返回字符串从 <code>start</code> 到（但不包括）<code>end</code> 的部分。与 <code>slice</code> 几乎相同，但它允许 <code>start</code> 大于 <code>end</code>。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> str = <span class="string">&quot;stringify&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 这些对于 substring 是相同的</span></span><br><span class="line"><span class="title function_">alert</span>( str.<span class="title function_">substring</span>(<span class="number">2</span>, <span class="number">6</span>) ); <span class="comment">// &quot;ring&quot;</span></span><br><span class="line"><span class="title function_">alert</span>( str.<span class="title function_">substring</span>(<span class="number">6</span>, <span class="number">2</span>) ); <span class="comment">// &quot;ring&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// ……但对 slice 是不同的：</span></span><br><span class="line"><span class="title function_">alert</span>( str.<span class="title function_">slice</span>(<span class="number">2</span>, <span class="number">6</span>) ); <span class="comment">// &quot;ring&quot;（一样）</span></span><br><span class="line"><span class="title function_">alert</span>( str.<span class="title function_">slice</span>(<span class="number">6</span>, <span class="number">2</span>) ); <span class="comment">// &quot;&quot;（空字符串）</span></span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">str.substr(start [, length])</span><br></pre></td></tr></table></figure>

<p>返回字符串从 <code>start</code> 开始的给定 <code>length</code> 的部分。与以前的方法相比，允许指定 <code>length</code> 而不是结束位置</p>
<p>第一个参数可能是负数，从结尾算起</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> str = <span class="string">&quot;stringify&quot;</span>;</span><br><span class="line"><span class="title function_">alert</span>( str.<span class="title function_">substr</span>(-<span class="number">4</span>, <span class="number">2</span>) ); <span class="comment">// &#x27;gi&#x27;，从第 4 位获取 2 个字符</span></span><br></pre></td></tr></table></figure>

<table>
<thead>
<tr>
<th align="left">方法</th>
<th align="left">选择方式……</th>
<th align="left">负值参数</th>
</tr>
</thead>
<tbody><tr>
<td align="left"><code>slice(start, end)</code></td>
<td align="left">从 <code>start</code> 到 <code>end</code>（不含 <code>end</code>）</td>
<td align="left">允许</td>
</tr>
<tr>
<td align="left"><code>substring(start, end)</code></td>
<td align="left">从 <code>start</code> 到 <code>end</code>（不含 <code>end</code>）</td>
<td align="left">负值被视为 <code>0</code></td>
</tr>
<tr>
<td align="left"><code>substr(start, length)</code></td>
<td align="left">从 <code>start</code> 开始获取长为 <code>length</code> 的字符串</td>
<td align="left">允许 <code>start</code> 为负数</td>
</tr>
</tbody></table>
<p><strong>使用哪一个？</strong></p>
<p>它们都可用于获取子字符串。正式一点来讲，<code>substr</code> 有一个小缺点：它不是在 JavaScript 核心规范中描述的，而是在附录 B 中。附录 B 的内容主要是描述因历史原因而遗留下来的仅浏览器特性。因此，理论上非浏览器环境可能无法支持 <code>substr</code>，但实际上它在别的地方也都能用。</p>
<p>相较于其他两个变体，<code>slice</code> 稍微灵活一些，它允许以负值作为参数并且写法更简短。因此仅仅记住这三种方法中的 <code>slice</code> 就足够了。</p>
<h2 id="比较字符串"><a href="#比较字符串" class="headerlink" title="比较字符串"></a><a target="_blank" rel="noopener" href="https://zh.javascript.info/string#bi-jiao-zi-fu-chuan">比较字符串</a></h2><p>所有的字符串都使用 <a target="_blank" rel="noopener" href="https://en.wikipedia.org/wiki/UTF-16">UTF-16</a> 编码。即：每个字符都有对应的数字代码。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">str.<span class="title function_">codePointAt</span>(pos)</span><br></pre></td></tr></table></figure>

<p>返回在 <code>pos</code> 位置的字符代码 </p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">String.fromCodePoint(code)</span><br></pre></td></tr></table></figure>

<p>通过数字 <code>code</code> 创建字符,可以用 <code>\u</code> 后跟十六进制代码，通过这些代码添加 Unicode 字符</p>
<p>调用 <a target="_blank" rel="noopener" href="https://developer.mozilla.org/zh/docs/Web/JavaScript/Reference/Global_Objects/String/localeCompare">str.localeCompare(str2)</a> 会根据语言规则返回一个整数，这个整数能指示字符串 <code>str</code> 在排序顺序中排在字符串 <code>str2</code> 前面、后面、还是相同：</p>
<ul>
<li>如果 <code>str</code> 排在 <code>str2</code> 前面，则返回负数。</li>
<li>如果 <code>str</code> 排在 <code>str2</code> 后面，则返回正数。</li>
<li>如果它们在相同位置，则返回 <code>0</code></li>
</ul>
<p>这个方法实际上在 <a target="_blank" rel="noopener" href="https://developer.mozilla.org/zh/docs/Web/JavaScript/Reference/Global_Objects/String/localeCompare">文档</a> 中指定了两个额外的参数，这两个参数允许它指定语言（默认语言从环境中获取，字符顺序视语言不同而不同）并设置诸如区分大小写，或应该将 <code>&quot;a&quot;</code> 和 <code>&quot;á&quot;</code> 作相同处理等附加的规则。</p>
<h2 id="内部，Unicode"><a href="#内部，Unicode" class="headerlink" title="内部，Unicode"></a><a target="_blank" rel="noopener" href="https://zh.javascript.info/string#nei-bu-unicode">内部，Unicode</a></h2><p>参考swift语言中可扩展字符集，可以处理 emoji、罕见的数学或象形文字或其他罕见的符号</p>
<h3 id="代理对"><a href="#代理对" class="headerlink" title="代理对"></a><a target="_blank" rel="noopener" href="https://zh.javascript.info/string#dai-li-dui">代理对</a></h3><h2 id="总结-1"><a href="#总结-1" class="headerlink" title="总结"></a><a target="_blank" rel="noopener" href="https://zh.javascript.info/string#zong-jie">总结</a></h2><ul>
<li>有 3 种类型的引号。反引号允许字符串跨越多行并可以使用 <code>$&#123;…&#125;</code> 在字符串中嵌入表达式。</li>
<li>JavaScript 中的字符串使用的是 UTF-16 编码。</li>
<li>我们可以使用像 <code>\n</code> 这样的特殊字符或通过使用 <code>\u...</code> 来操作它们的 Unicode 进行字符插入。</li>
<li>获取字符时，使用 <code>[]</code>。</li>
<li>获取子字符串，使用 <code>slice</code> 或 <code>substring</code>。</li>
<li>字符串的大&#x2F;小写转换，使用：<code>toLowerCase/toUpperCase</code>。</li>
<li>查找子字符串时，使用 <code>indexOf</code> 或 <code>includes/startsWith/endsWith</code> 进行简单检查。</li>
<li>根据语言比较字符串时使用 <code>localeCompare</code>，否则将按字符代码进行比较。</li>
</ul>
<p>还有其他几种有用的字符串方法：</p>
<ul>
<li><code>str.trim()</code> —— 删除字符串前后的空格 (“trims”)。</li>
<li><code>str.repeat(n)</code> —— 重复字符串 <code>n</code> 次。</li>
<li>……更多内容细节请参见 <a target="_blank" rel="noopener" href="https://developer.mozilla.org/zh/docs/Web/JavaScript/Reference/Global_Objects/String">手册</a>。</li>
</ul>
<p>字符串还具有使用正则表达式进行搜索&#x2F;替换的方法。</p>
<h1 id="数组"><a href="#数组" class="headerlink" title="数组"></a>数组</h1><h2 id="声明"><a href="#声明" class="headerlink" title="声明"></a><a target="_blank" rel="noopener" href="https://zh.javascript.info/array#sheng-ming">声明</a></h2><p>创建一个空数组有两种语法：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> arr = <span class="keyword">new</span> <span class="title class_">Array</span>();</span><br><span class="line"><span class="keyword">let</span> arr = [];</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> fruits = [<span class="string">&quot;Apple&quot;</span>, <span class="string">&quot;Orange&quot;</span>, <span class="string">&quot;Plum&quot;</span>];</span><br><span class="line"></span><br><span class="line"><span class="title function_">alert</span>( fruits[<span class="number">0</span>] ); <span class="comment">// Apple</span></span><br><span class="line"><span class="title function_">alert</span>( fruits[<span class="number">1</span>] ); <span class="comment">// Orange</span></span><br><span class="line"><span class="title function_">alert</span>( fruits[<span class="number">2</span>] ); <span class="comment">// Plum</span></span><br></pre></td></tr></table></figure>

<p>数组元素从 0 开始编号，可以通过方括号中的数字获取元素</p>
<p><code>length</code> 属性的值是数组中元素的总个数, 用 <code>alert</code> 来显示整个数组。</p>
<p>数组可以存储任何类型的元素, 数组就像对象一样，可以以逗号结尾</p>
<h2 id="使用-“at”-获取最后一个元素"><a href="#使用-“at”-获取最后一个元素" class="headerlink" title="使用 “at” 获取最后一个元素"></a><a target="_blank" rel="noopener" href="https://zh.javascript.info/array#shi-yong-at-huo-qu-zui-hou-yi-ge-yuan-su">使用 “at” 获取最后一个元素</a></h2><p>数组不支持从-1开始的反向索引，可以显式地计算最后一个元素的索引，然后访问它：<code>fruits[fruits.length - 1]</code>。</p>
<p>有一个更简短的语法 <code>fruits.at(-1)</code></p>
<p><code>arr.at(i)</code>：</p>
<ul>
<li>如果 <code>i &gt;= 0</code>，则与 <code>arr[i]</code> 完全相同。</li>
<li>对于 <code>i</code> 为负数的情况，它则从数组的尾部向前数。</li>
</ul>
<h2 id="pop-push-shift-unshift-方法"><a href="#pop-push-shift-unshift-方法" class="headerlink" title="pop&#x2F;push, shift&#x2F;unshift 方法"></a><a target="_blank" rel="noopener" href="https://zh.javascript.info/array#poppushshiftunshift-fang-fa">pop&#x2F;push, shift&#x2F;unshift 方法</a></h2><p><a target="_blank" rel="noopener" href="https://en.wikipedia.org/wiki/Queue_(abstract_data_type)">队列（queue）</a>是最常见的使用数组的方法之一。在计算机科学中，这表示支持两个操作的一个有序元素的集合：</p>
<ul>
<li><p><code>push</code> 在末端添加一个元素.</p>
</li>
<li><p><code>shift</code> 取出队列首端的一个元素，整个队列往前移，这样原先排第二的元素现在排在了第一。</p>
</li>
<li></li>
<li><p><code>pop</code> 从末端取出一个元素.</p>
</li>
<li><p><code>pop</code></p>
</li>
</ul>
<p>取出并返回数组的最后一个元素</p>
<ul>
<li><code>push</code></li>
</ul>
<p>在数组末端添加元素, 调用 <code>fruits.push(...)</code> 与 <code>fruits[fruits.length] = ...</code> 是一样的</p>
<p><strong>作用于数组首端的方法：</strong></p>
<ul>
<li><code>shift</code></li>
</ul>
<p>取出数组的第一个元素并返回它</p>
<ul>
<li><code>unshift</code></li>
</ul>
<p>在数组的首端添加元素</p>
<p><code>push</code> 和 <code>unshift</code> 方法都可以一次添加多个元素</p>
<h2 id="内部"><a href="#内部" class="headerlink" title="内部"></a><a target="_blank" rel="noopener" href="https://zh.javascript.info/array#nei-bu">内部</a></h2><p>数组是一种特殊的对象。使用方括号来访问属性 <code>arr[0]</code> 实际上是来自于对象的语法。它其实与 <code>obj[key]</code>相同，其中 <code>arr</code> 是对象，而数字用作键（key）。</p>
<p>它们扩展了对象，提供了特殊的方法来处理有序的数据集合以及 <code>length</code> 属性。但从本质上讲，它仍然是一个对象。<strong>在 JavaScript 中只有 8 种基本的数据类型</strong>（详见 <a target="_blank" rel="noopener" href="https://zh.javascript.info/types">数据类型</a> 一章）。数组是一个对象，因此其行为也像一个对象。</p>
<p>数组是通过引用来复制</p>
<p>数组误用的几种方式:</p>
<ul>
<li>添加一个非数字的属性，比如 <code>arr.test = 5</code>。</li>
<li>制造空洞，比如：添加 <code>arr[0]</code>，然后添加 <code>arr[1000]</code> (它们中间什么都没有)。</li>
<li>以倒序填充数组，比如 <code>arr[1000]</code>，<code>arr[999]</code> 等等。</li>
</ul>
<h2 id="性能"><a href="#性能" class="headerlink" title="性能"></a><a target="_blank" rel="noopener" href="https://zh.javascript.info/array#xing-neng">性能</a></h2><p><code>push/pop</code> 方法运行的比较快，而 <code>shift/unshift</code> 比较慢。</p>
<h2 id="循环"><a href="#循环" class="headerlink" title="循环"></a><a target="_blank" rel="noopener" href="https://zh.javascript.info/array#xun-huan">循环</a></h2><p>使用 <code>for..in</code> </p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> arr = [<span class="string">&quot;Apple&quot;</span>, <span class="string">&quot;Orange&quot;</span>, <span class="string">&quot;Pear&quot;</span>];</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> key <span class="keyword">in</span> arr) &#123;</span><br><span class="line">  <span class="title function_">alert</span>( arr[key] ); <span class="comment">// Apple, Orange, Pear,注意要用key</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>会有一些潜在问题存在：</p>
<ol>
<li><p><code>for..in</code> 循环会遍历 <strong>所有属性</strong>，不仅仅是这些数字属性。</p>
<p> 在浏览器和其它环境中有一种称为“类数组”的对象，它们 <strong>看似是数组</strong>。也就是说，它们有 <code>length</code> 和索引属性，但是也可能有其它的非数字的属性和方法，这通常是我们不需要的。<code>for..in</code> 循环会把它们都列出来。所以如果我们需要处理类数组对象，这些“额外”的属性就会存在问题。</p>
</li>
<li><p><code>for..in</code> 循环适用于普通对象，并且做了对应的优化。但是不适用于数组，因此速度要慢 10-100 倍。</p>
</li>
</ol>
<p>通常来说，不应该用 <code>for..in</code> 来处理数组。</p>
<h2 id="关于-“length”"><a href="#关于-“length”" class="headerlink" title="关于 “length”"></a><a target="_blank" rel="noopener" href="https://zh.javascript.info/array#guan-yu-length">关于 “length”</a></h2><p>当修改数组的时候，<code>length</code> 属性会自动更新。准确来说，它实际上不是数组里元素的个数，而是最大的数字索引值加一。</p>
<p>例如，一个数组只有一个元素，但是这个元素的索引值很大，那么这个数组的 <code>length</code> 也会很大</p>
<p><code>length</code> 属性的另一个有意思的点是它是可写的。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> arr = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>];</span><br><span class="line"></span><br><span class="line">arr.<span class="property">length</span> = <span class="number">2</span>; <span class="comment">// 截断到只剩 2 个元素</span></span><br><span class="line"><span class="title function_">alert</span>( arr ); <span class="comment">// [1, 2]</span></span><br><span class="line"></span><br><span class="line">arr.<span class="property">length</span> = <span class="number">5</span>; <span class="comment">// 又把 length 加回来</span></span><br><span class="line"><span class="title function_">alert</span>( arr[<span class="number">3</span>] ); <span class="comment">// undefined：被截断的那些数值并没有回来</span></span><br></pre></td></tr></table></figure>

<p>清空数组最简单的方法就是：<code>arr.length = 0;</code></p>
<h2 id="new-Array"><a href="#new-Array" class="headerlink" title="new Array()"></a><a target="_blank" rel="noopener" href="https://zh.javascript.info/array#new-array">new Array()</a></h2><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> arr = <span class="keyword">new</span> <span class="title class_">Array</span>(<span class="string">&quot;Apple&quot;</span>, <span class="string">&quot;Pear&quot;</span>, <span class="string">&quot;etc&quot;</span>);</span><br></pre></td></tr></table></figure>

<p>它很少被使用，因为方括号 <code>[]</code> 更短更简洁。而且，这种语法还有一个棘手的特性</p>
<p>如果使用单个参数（即数字）调用 <code>new Array</code>，那么它会创建一个 <strong>指定了长度，却没有任何项</strong> 的数组。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> arr = <span class="keyword">new</span> <span class="title class_">Array</span>(<span class="number">2</span>); <span class="comment">// 会创建一个 [2] 的数组吗？</span></span><br><span class="line"></span><br><span class="line"><span class="title function_">alert</span>( arr[<span class="number">0</span>] ); <span class="comment">// undefined！没有元素。</span></span><br><span class="line"></span><br><span class="line"><span class="title function_">alert</span>( arr.<span class="property">length</span> ); <span class="comment">// length 2</span></span><br></pre></td></tr></table></figure>

<h2 id="多维数组"><a href="#多维数组" class="headerlink" title="多维数组"></a><a target="_blank" rel="noopener" href="https://zh.javascript.info/array#duo-wei-shu-zu">多维数组</a></h2><h2 id="toString-NaN"><a href="#toString-NaN" class="headerlink" title="toString"></a><a target="_blank" rel="noopener" href="https://zh.javascript.info/array#tostring">toString</a></h2><p>数组有自己的 <code>toString</code> 方法的实现，会返回以逗号隔开的元素列表。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="title function_">alert</span>( [] + <span class="number">1</span> ); <span class="comment">// &quot;1&quot;</span></span><br><span class="line"><span class="title function_">alert</span>( [<span class="number">1</span>] + <span class="number">1</span> ); <span class="comment">// &quot;11&quot;</span></span><br><span class="line"><span class="title function_">alert</span>( [<span class="number">1</span>,<span class="number">2</span>] + <span class="number">1</span> ); <span class="comment">// &quot;1,21&quot;</span></span><br></pre></td></tr></table></figure>

<p>数组没有 <code>Symbol.toPrimitive</code>，也没有 <code>valueOf</code>，它们只能执行 <code>toString</code> 进行转换，所以这里 <code>[]</code>就变成了一个空字符串，<code>[1]</code> 变成了 <code>&quot;1&quot;</code>，<code>[1,2]</code> 变成了 <code>&quot;1,2&quot;</code>。</p>
<h2 id="不要使用-比较数组"><a href="#不要使用-比较数组" class="headerlink" title="不要使用 &#x3D;&#x3D; 比较数组"></a><a target="_blank" rel="noopener" href="https://zh.javascript.info/array#bu-yao-shi-yong-bi-jiao-shu-zu">不要使用 &#x3D;&#x3D; 比较数组</a></h2><p><code>==</code>会像处理任意对象那样处理数组。</p>
<ul>
<li>仅当两个对象引用的是同一个对象时，它们才相等 <code>==</code>。</li>
<li>如果 <code>==</code> 左右两个参数之中有一个参数是对象，另一个参数是原始类型，那么该对象将会被转换为原始类型，转换规则如 <a target="_blank" rel="noopener" href="https://zh.javascript.info/object-toprimitive">对象 —— 原始值转换</a> 一章所述。</li>
<li>……<code>null</code> 和 <code>undefined</code> 相等 <code>==</code>，且各自不等于任何其他的值。</li>
</ul>
<p>严格比较 <code>===</code> 更简单，因为它不会进行类型转换。</p>
<p>如果使用 <code>==</code> 来比较数组，除非比较的是两个引用同一数组的变量，否则它们永远不相等。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 在 [] 被转换为 &#x27;&#x27; 后</span></span><br><span class="line"><span class="title function_">alert</span>( <span class="number">0</span> == <span class="string">&#x27;&#x27;</span> ); <span class="comment">// true，因为 &#x27;&#x27; 被转换成了数字 0</span></span><br><span class="line"></span><br><span class="line"><span class="title function_">alert</span>(<span class="string">&#x27;0&#x27;</span> == <span class="string">&#x27;&#x27;</span> ); <span class="comment">// false，没有进一步的类型转换，是不同的字符串</span></span><br></pre></td></tr></table></figure>

<p>可以在循环中或者使用下一章中我们将介绍的迭代方法逐项地比较它们。</p>
<h2 id="总结-2"><a href="#总结-2" class="headerlink" title="总结"></a><a target="_blank" rel="noopener" href="https://zh.javascript.info/array#zong-jie">总结</a></h2><p>数组是一种特殊的对象，适用于存储和管理有序的数据项。</p>
<p>声明：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 方括号 (常见用法)</span></span><br><span class="line"><span class="keyword">let</span> arr = [item1, item2...];</span><br><span class="line"></span><br><span class="line"><span class="comment">// new Array (极其少见)</span></span><br><span class="line"><span class="keyword">let</span> arr = <span class="keyword">new</span> <span class="title class_">Array</span>(item1, item2...);</span><br></pre></td></tr></table></figure>

<p>调用 <code>new Array(number)</code> 会创建一个给定长度的数组，但不含有任何项。</p>
<ul>
<li><code>length</code> 属性是数组的长度，准确地说，它是数组最后一个数字索引值加一。它由数组方法自动调整。</li>
<li>如果我们手动缩短 <code>length</code>，那么数组就会被截断。</li>
</ul>
<p>获取元素：</p>
<ul>
<li>你可以通过元素的索引获取元素，例如 <code>arr[0]</code></li>
<li>我们也可以使用允许负索引的 <code>at(i)</code> 方法。对于负值的 <code>i</code>，它会从数组的末尾往回数。如果 <code>i &gt;= 0</code>，它的工作方式与 <code>arr[i]</code> 相同。</li>
</ul>
<p>我们可以通过下列操作以双端队列的方式使用数组：</p>
<ul>
<li><code>push(...items)</code> 在末端添加 <code>items</code> 项。</li>
<li><code>pop()</code> 从末端移除并返回该元素。</li>
<li><code>shift()</code> 从首端移除并返回该元素。</li>
<li><code>unshift(...items)</code> 从首端添加 <code>items</code> 项。</li>
</ul>
<p>遍历数组的元素：</p>
<ul>
<li><code>for (let i=0; i&lt;arr.length; i++)</code> — 运行得最快，可兼容旧版本浏览器。</li>
<li><code>for (let item of arr)</code> — 现代语法，只能访问 items。</li>
<li><code>for (let i in arr)</code> — 永远不要用这个。</li>
</ul>
<p>比较数组时，不要使用 <code>==</code> 运算符（当然也不要使用 <code>&gt;</code> 和 <code>&lt;</code> 等运算符），因为它们不会对数组进行特殊处理。它们通常会像处理任意对象那样处理数组，这通常不是我们想要的。</p>
<p>但是，我们可以使用 <code>for..of</code> 循环来逐项比较数组。</p>
<h1 id="数组方法"><a href="#数组方法" class="headerlink" title="数组方法"></a>数组方法</h1><h3 id="splice"><a href="#splice" class="headerlink" title="splice"></a><a target="_blank" rel="noopener" href="https://zh.javascript.info/array-methods#splice">splice</a></h3><p>可以做所有事情：添加，删除和插入元素。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">arr.splice(start[, deleteCount, elem1, ..., elemN])</span><br></pre></td></tr></table></figure>

<p>它从索引 <code>start</code> 开始修改 <code>arr</code>：删除 <code>deleteCount</code> 个元素并在当前位置插入 <code>elem1, ..., elemN</code>。最后<strong>返回</strong>被删除的元素所组成的数组。</p>
<p>我们可以将 <code>deleteCount</code> 设置为 <code>0</code>，<code>splice</code> 方法就能够插入元素而不用删除任何元素。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> arr = [<span class="string">&quot;I&quot;</span>, <span class="string">&quot;study&quot;</span>, <span class="string">&quot;JavaScript&quot;</span>];</span><br><span class="line"></span><br><span class="line"><span class="comment">// 从索引 2 开始</span></span><br><span class="line"><span class="comment">// 删除 0 个元素</span></span><br><span class="line"><span class="comment">// 然后插入 &quot;complex&quot; 和 &quot;language&quot;</span></span><br><span class="line">arr.<span class="title function_">splice</span>(<span class="number">2</span>, <span class="number">0</span>, <span class="string">&quot;complex&quot;</span>, <span class="string">&quot;language&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="title function_">alert</span>( arr ); <span class="comment">// &quot;I&quot;, &quot;study&quot;, &quot;complex&quot;, &quot;language&quot;, &quot;JavaScript&quot;</span></span><br></pre></td></tr></table></figure>

<p><strong>允许负向索引</strong>，在这里和其他数组方法中，负向索引都是被允许的。它们从数组末尾计算位置。</p>
<h3 id="slice"><a href="#slice" class="headerlink" title="slice"></a><a target="_blank" rel="noopener" href="https://zh.javascript.info/array-methods#slice">slice</a></h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">arr.<span class="title function_">slice</span>([start], [end])</span><br></pre></td></tr></table></figure>

<p>返回一个新数组，将所有从索引 <code>start</code> 到 <code>end</code>（不包括 <code>end</code>）的数组项复制到一个新的数组。<code>start</code> 和 <code>end</code> 都可以是负数，在这种情况下，从末尾计算索引。</p>
<p>不带参数地调用它：<code>arr.slice()</code> 会创建一个 <code>arr</code> 的副本。其通常用于获取副本，以进行不影响原始数组的进一步转换。</p>
<h3 id="concat"><a href="#concat" class="headerlink" title="concat"></a><a target="_blank" rel="noopener" href="https://zh.javascript.info/array-methods#concat">concat</a></h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">arr.<span class="title function_">concat</span>(arg1, arg2...)</span><br></pre></td></tr></table></figure>

<p>接受任意数量的参数 —— 数组或值都可以。结果是一个包含来自于 <code>arr</code>，然后是 <code>arg1</code>，<code>arg2</code> 的元素的新数组。</p>
<p>通常，它只复制数组中的元素。其他对象，即使它们看起来像数组一样，但仍然会被作为一个整体添加。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> arr = [<span class="number">1</span>, <span class="number">2</span>];</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> arrayLike = &#123;</span><br><span class="line">  <span class="number">0</span>: <span class="string">&quot;something&quot;</span>,</span><br><span class="line">  <span class="attr">length</span>: <span class="number">1</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="title function_">alert</span>( arr.<span class="title function_">concat</span>(arrayLike) ); <span class="comment">// 1,2,[object Object]</span></span><br></pre></td></tr></table></figure>

<p>如果类数组对象具有 <code>Symbol.isConcatSpreadable</code> 属性，那么它就会被 <code>concat</code> 当作一个数组来处理：此对象中的元素将被添加</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> arr = [<span class="number">1</span>, <span class="number">2</span>];</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> arrayLike = &#123;</span><br><span class="line">  <span class="number">0</span>: <span class="string">&quot;something&quot;</span>,</span><br><span class="line">  <span class="number">1</span>: <span class="string">&quot;else&quot;</span>,</span><br><span class="line">  [<span class="title class_">Symbol</span>.<span class="property">isConcatSpreadable</span>]: <span class="literal">true</span>,</span><br><span class="line">  <span class="attr">length</span>: <span class="number">2</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="title function_">alert</span>( arr.<span class="title function_">concat</span>(arrayLike) ); <span class="comment">// 1,2,something,else</span></span><br></pre></td></tr></table></figure>

<h2 id="遍历：forEach"><a href="#遍历：forEach" class="headerlink" title="遍历：forEach"></a><a target="_blank" rel="noopener" href="https://zh.javascript.info/array-methods#bian-li-foreach">遍历：forEach</a></h2><p><a target="_blank" rel="noopener" href="https://developer.mozilla.org/zh/docs/Web/JavaScript/Reference/Global_Objects/Array/forEach">arr.forEach</a> 方法允许为数组的每个元素都运行一个函数。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">arr.<span class="title function_">forEach</span>(<span class="keyword">function</span>(<span class="params">item, index, array</span>) &#123;</span><br><span class="line">  <span class="comment">// ... do something with item</span></span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">[<span class="string">&quot;Bilbo&quot;</span>, <span class="string">&quot;Gandalf&quot;</span>, <span class="string">&quot;Nazgul&quot;</span>].<span class="title function_">forEach</span>(<span class="function">(<span class="params">item, index, array</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="title function_">alert</span>(<span class="string">`<span class="subst">$&#123;item&#125;</span> is at index <span class="subst">$&#123;index&#125;</span> in <span class="subst">$&#123;array&#125;</span>`</span>);</span><br><span class="line">&#125;); </span><br><span class="line"><span class="comment">//Bilbo at 0 of Bilbo,Gandalf,Nazgul</span></span><br><span class="line"><span class="comment">//Gandalf at 1 of Bilbo,Gandalf,Nazgul</span></span><br></pre></td></tr></table></figure>

<h2 id="在数组中搜索"><a href="#在数组中搜索" class="headerlink" title="在数组中搜索"></a><a target="_blank" rel="noopener" href="https://zh.javascript.info/array-methods#zai-shu-zu-zhong-sou-suo">在数组中搜索</a></h2><h3 id="indexOf-lastIndexOf-和-includes"><a href="#indexOf-lastIndexOf-和-includes" class="headerlink" title="indexOf&#x2F;lastIndexOf 和 includes"></a><a target="_blank" rel="noopener" href="https://zh.javascript.info/array-methods#indexoflastindexof-he-includes">indexOf&#x2F;lastIndexOf 和 includes</a></h3><p><a target="_blank" rel="noopener" href="https://developer.mozilla.org/zh/docs/Web/JavaScript/Reference/Global_Objects/Array/indexOf">arr.indexOf</a> 和 <a target="_blank" rel="noopener" href="https://developer.mozilla.org/zh/docs/Web/JavaScript/Reference/Global_Objects/Array/includes">arr.includes</a> 方法语法相似，并且作用基本上也与字符串的方法相同，只不过这里是对数组元素而不是字符进行操作：</p>
<ul>
<li><code>arr.indexOf(item, from)</code> —— 从索引 <code>from</code> 开始搜索 <code>item</code>，如果找到则返回索引，否则返回 <code>-1</code>。</li>
<li><code>arr.includes(item, from)</code> —— 从索引 <code>from</code> 开始搜索 <code>item</code>，如果找到则返回 <code>true</code>如果没找到，则返回 <code>false</code>）。</li>
</ul>
<p>通常使用这些方法时只会传入一个参数：传入 <code>item</code> 开始搜索。默认情况下，搜索是从头开始的。</p>
<p><code>indexOf</code> 和 <code>includes</code> 使用严格相等 <code>===</code> 进行比较。所以，如果我们搜索 <code>false</code>，它会准确找到 <code>false</code> 而不是数字 <code>0</code>。</p>
<p>方法 <a target="_blank" rel="noopener" href="https://developer.mozilla.org/zh/docs/Web/JavaScript/Reference/Global_Objects/Array/lastIndexOf">arr.lastIndexOf</a> 与 <code>indexOf</code> 相同，但从右向左查找。</p>
<p><strong>方法</strong> <code>includes</code> <strong>可以正确的处理</strong> <code>NaN</code>，与 <code>indexOf</code> 不同</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span>  arr = [<span class="title class_">NaN</span>];</span><br><span class="line"><span class="title function_">alert</span>( arr.<span class="title function_">indexOf</span>(<span class="title class_">NaN</span>) );</span><br><span class="line"><span class="title function_">alert</span>( arr.<span class="title function_">includes</span>(<span class="title class_">NaN</span>) );</span><br></pre></td></tr></table></figure>

<p>因为 <code>includes</code> 是在比较晚的时候才被添加到 JavaScript 中的，并且在内部使用了更新了的比较算法。</p>
<h3 id="find-和-findIndex-findLastIndex"><a href="#find-和-findIndex-findLastIndex" class="headerlink" title="find 和 findIndex&#x2F;findLastIndex"></a><a target="_blank" rel="noopener" href="https://zh.javascript.info/array-methods#find-he-findindexfindlastindex">find 和 findIndex&#x2F;findLastIndex</a></h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> result = arr.<span class="title function_">find</span>(<span class="keyword">function</span>(<span class="params">item, index, array</span>) &#123;</span><br><span class="line">  <span class="comment">// 如果function返回 true，则find返回 item 并停止迭代</span></span><br><span class="line">  <span class="comment">// 对于假值（falsy）的情况，则返回 undefined</span></span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<ul>
<li><code>item</code> 是元素。</li>
<li><code>index</code> 是它的索引。</li>
<li><code>array</code> 是数组本身。</li>
</ul>
<p>如果它返回 <code>true</code>，则搜索停止，并返回 <code>item</code>。如果没有搜索到，则返回 <code>undefined</code>。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> users = [</span><br><span class="line">  &#123;<span class="attr">id</span>: <span class="number">1</span>, <span class="attr">name</span>: <span class="string">&quot;John&quot;</span>&#125;,</span><br><span class="line">  &#123;<span class="attr">id</span>: <span class="number">2</span>, <span class="attr">name</span>: <span class="string">&quot;Pete&quot;</span>&#125;,</span><br><span class="line">  &#123;<span class="attr">id</span>: <span class="number">3</span>, <span class="attr">name</span>: <span class="string">&quot;Mary&quot;</span>&#125;</span><br><span class="line">];</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> user = users.<span class="title function_">find</span>(<span class="function"><span class="params">item</span> =&gt;</span> item.<span class="property">id</span> == <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line"><span class="title function_">alert</span>(user.<span class="property">name</span>); <span class="comment">// John</span></span><br></pre></td></tr></table></figure>

<p><a target="_blank" rel="noopener" href="https://developer.mozilla.org/zh/docs/Web/JavaScript/Reference/Global_Objects/Array/findIndex">arr.findIndex</a> 方法（与 <code>arr.find</code>）具有相同的语法，但它返回找到的元素的索引，而不是元素本身。如果没找到，则返回 <code>-1</code>。</p>
<p><a target="_blank" rel="noopener" href="https://developer.mozilla.org/zh/docs/Web/JavaScript/Reference/Global_Objects/Array/findLastIndex">arr.findLastIndex</a> 方法类似于 <code>findIndex</code>，但从右向左搜索，类似于 <code>lastIndexOf</code>。</p>
<h3 id="filter"><a href="#filter" class="headerlink" title="filter"></a><a target="_blank" rel="noopener" href="https://zh.javascript.info/array-methods#filter">filter</a></h3><p><code>find</code> 方法搜索的是使函数返回 <code>true</code> 的第一个（单个）元素。</p>
<p>如果需要匹配的有很多，可以使用 <a target="_blank" rel="noopener" href="https://developer.mozilla.org/zh/docs/Web/JavaScript/Reference/Global_Objects/Array/filter">arr.filter(fn)</a>。</p>
<p>语法与 <code>find</code> 大致相同，但是 <code>filter</code> 返回的是所有匹配元素组成的数组</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> results = arr.<span class="title function_">filter</span>(<span class="keyword">function</span>(<span class="params">item, index, array</span>) &#123;</span><br><span class="line">  <span class="comment">// 如果 true, item 被 push 到 results，迭代继续</span></span><br><span class="line">  <span class="comment">// 如果什么都没找到，则返回空数组</span></span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<h2 id="转换数组"><a href="#转换数组" class="headerlink" title="转换数组"></a><a target="_blank" rel="noopener" href="https://zh.javascript.info/array-methods#zhuan-huan-shu-zu">转换数组</a></h2><h3 id="map"><a href="#map" class="headerlink" title="map"></a><a target="_blank" rel="noopener" href="https://zh.javascript.info/array-methods#map">map</a></h3><p><a target="_blank" rel="noopener" href="https://developer.mozilla.org/zh/docs/Web/JavaScript/Reference/Global_Objects/Array/map">arr.map</a> 方法是最有用和经常使用的方法之一。它对数组的每个元素都调用函数，并返回结果数组。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> result = arr.<span class="title function_">map</span>(<span class="keyword">function</span>(<span class="params">item, index, array</span>) &#123;</span><br><span class="line">  <span class="comment">// 返回新值而不是当前元素</span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<h3 id="sort-fn"><a href="#sort-fn" class="headerlink" title="sort(fn)"></a><a target="_blank" rel="noopener" href="https://zh.javascript.info/array-methods#sortfn">sort(fn)</a></h3><p><a target="_blank" rel="noopener" href="https://developer.mozilla.org/zh/docs/Web/JavaScript/Reference/Global_Objects/Array/sort">arr.sort</a> 方法对数组进行 <strong>原位（in-place）</strong> 排序，更改元素的顺序。(原位是指在此数组内，而非生成一个新数组。)</p>
<p>它还返回排序后的数组，但是返回值通常会被忽略，因为修改了 <code>arr</code> 本身</p>
<p><strong>这些元素默认情况下被按字符串进行排序。</strong></p>
<p>要使用自己的排序顺序，需要提供一个函数作为 <code>arr.sort()</code> 的参数。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">compare</span>(<span class="params">a, b</span>) &#123;</span><br><span class="line">  <span class="keyword">if</span> (a &gt; b) <span class="keyword">return</span> <span class="number">1</span>; <span class="comment">// 如果第一个值比第二个值大</span></span><br><span class="line">  <span class="keyword">if</span> (a == b) <span class="keyword">return</span> <span class="number">0</span>; <span class="comment">// 如果两个值相等</span></span><br><span class="line">  <span class="keyword">if</span> (a &lt; b) <span class="keyword">return</span> -<span class="number">1</span>; <span class="comment">// 如果第一个值比第二个值小</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">arr.<span class="title function_">sort</span>(<span class="function">(<span class="params">a, b</span>) =&gt;</span> a - b);</span><br></pre></td></tr></table></figure>

<p><strong>使用</strong> <code>localeCompare</code> <strong>for strings</strong></p>
<p>字符串比较默认通过字母的代码比较字母。</p>
<p>对于许多字母，最好使用 <code>str.localeCompare</code> 方法正确地对字母进行排序，例如 <code>Ö</code>。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> countries = [<span class="string">&#x27;Österreich&#x27;</span>, <span class="string">&#x27;Andorra&#x27;</span>, <span class="string">&#x27;Vietnam&#x27;</span>];</span><br><span class="line"></span><br><span class="line"><span class="title function_">alert</span>( countries.<span class="title function_">sort</span>( <span class="function">(<span class="params">a, b</span>) =&gt;</span> a &gt; b ? <span class="number">1</span> : -<span class="number">1</span>) ); <span class="comment">// Andorra, Vietnam, Österreich（错的）</span></span><br><span class="line"></span><br><span class="line"><span class="title function_">alert</span>( countries.<span class="title function_">sort</span>( <span class="function">(<span class="params">a, b</span>) =&gt;</span> a.<span class="title function_">localeCompare</span>(b) ) ); <span class="comment">// Andorra,Österreich,Vietnam（对的！）</span></span><br></pre></td></tr></table></figure>

<h3 id="reverse"><a href="#reverse" class="headerlink" title="reverse"></a><a target="_blank" rel="noopener" href="https://zh.javascript.info/array-methods#reverse">reverse</a></h3><p><a target="_blank" rel="noopener" href="https://developer.mozilla.org/zh/docs/Web/JavaScript/Reference/Global_Objects/Array/reverse">arr.reverse</a> 方法用于颠倒 <code>arr</code> 中元素的顺序。</p>
<h3 id="split-和-join"><a href="#split-和-join" class="headerlink" title="split 和 join"></a><a target="_blank" rel="noopener" href="https://zh.javascript.info/array-methods#split-he-join">split 和 join</a></h3><p><a target="_blank" rel="noopener" href="https://developer.mozilla.org/zh/docs/Web/JavaScript/Reference/Global_Objects/String/split">str.split(delim)</a> 方法通过给定的分隔符 <code>delim</code> 将字符串分割成一个数组。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> arr = <span class="string">&#x27;Bilbo, Gandalf, Nazgul, Saruman&#x27;</span>.<span class="title function_">split</span>(<span class="string">&#x27;, &#x27;</span>, <span class="number">2</span>);</span><br><span class="line"></span><br><span class="line"><span class="title function_">alert</span>(arr); <span class="comment">// Bilbo, Gandalf</span></span><br></pre></td></tr></table></figure>

<p><strong>拆分为字母</strong></p>
<p>调用带有空参数 <code>s</code> 的 <code>split(s)</code>，会将字符串拆分为字母数组：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> str = <span class="string">&quot;test&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="title function_">alert</span>( str.<span class="title function_">split</span>(<span class="string">&#x27;&#x27;</span>) ); <span class="comment">// t,e,s,t</span></span><br></pre></td></tr></table></figure>

<p><a target="_blank" rel="noopener" href="https://developer.mozilla.org/zh/docs/Web/JavaScript/Reference/Global_Objects/Array/join">arr.join(glue)</a> 与 <code>split</code> 相反。它会在它们之间创建一串由 <code>glue</code> 粘合的 <code>arr</code> 项。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> arr = [<span class="string">&#x27;Bilbo&#x27;</span>, <span class="string">&#x27;Gandalf&#x27;</span>, <span class="string">&#x27;Nazgul&#x27;</span>];</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> str = arr.<span class="title function_">join</span>(<span class="string">&#x27;;&#x27;</span>); <span class="comment">// 使用分号 ; 将数组粘合成字符串</span></span><br><span class="line"></span><br><span class="line"><span class="title function_">alert</span>( str ); <span class="comment">// Bilbo;Gandalf;Nazgul</span></span><br></pre></td></tr></table></figure>

<h3 id="reduce-reduceRight"><a href="#reduce-reduceRight" class="headerlink" title="reduce&#x2F;reduceRight"></a><a target="_blank" rel="noopener" href="https://zh.javascript.info/array-methods#reducereduceright">reduce&#x2F;reduceRight</a></h3><p>当需要遍历一个数组时 —— 可以使用 <code>forEach</code>，<code>for</code> 或 <code>for..of</code>。</p>
<p>当需要遍历并返回每个元素的数据时 —— 可以使用 <code>map</code>。</p>
<p><a target="_blank" rel="noopener" href="https://developer.mozilla.org/zh/docs/Web/JavaScript/Reference/Global_Objects/Array/reduce">arr.reduce</a> 方法和 <a target="_blank" rel="noopener" href="https://developer.mozilla.org/zh/docs/Web/JavaScript/Reference/Global_Objects/Array/reduceRight">arr.reduceRight</a> 方法和上面的种类差不多，但稍微复杂一点。它们用于根据数组计算单个值。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> value = arr.<span class="title function_">reduce</span>(<span class="keyword">function</span>(<span class="params">accumulator, item, index, array</span>) &#123;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;, [initial]);</span><br></pre></td></tr></table></figure>

<p>该函数一个接一个地应用于所有数组元素，并将其结果“搬运（carry on）”到下一个调用。</p>
<p>参数：</p>
<ul>
<li><code>accumulator</code> —— 是上一个函数调用的结果，第一次等于 <code>initial</code>（如果提供了 <code>initial</code> 的话）。</li>
<li><code>item</code> —— 当前的数组元素。</li>
<li><code>index</code> —— 当前索引。</li>
<li><code>arr</code> —— 数组本身。</li>
</ul>
<p>应用函数时，上一个函数调用的结果将作为第一个参数传递给下一个函数。</p>
<p>因此，第一个参数本质上是累加器，用于存储所有先前执行的组合结果。最后，它成为 <code>reduce</code> 的结果。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> arr = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>];</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> result = arr.<span class="title function_">reduce</span>(<span class="function">(<span class="params">sum, current</span>) =&gt;</span> sum + current, <span class="number">0</span>);</span><br><span class="line"><span class="comment">// let result = arr.reduce((sum, current) =&gt; sum += current);</span></span><br><span class="line"></span><br><span class="line"><span class="title function_">alert</span>(result); <span class="comment">// 15</span></span><br></pre></td></tr></table></figure>

<p>如果没有初始值，那么 <code>reduce</code> 会将数组的第一个元素作为初始值，并从第二个元素开始迭代。此时如果数组为空，那么在没有初始值的情况下调用 <code>reduce</code> 会导致错误。</p>
<p><a target="_blank" rel="noopener" href="https://developer.mozilla.org/zh/docs/Web/JavaScript/Reference/Global_Objects/Array/reduceRight">arr.reduceRight</a> 和 <a target="_blank" rel="noopener" href="https://developer.mozilla.org/zh/docs/Web/JavaScript/Reference/Global_Objects/Array/reduce">arr.reduce</a> 方法的功能一样，只是遍历为从右到左。</p>
<h2 id="Array-isArray"><a href="#Array-isArray" class="headerlink" title="Array.isArray"></a><a target="_blank" rel="noopener" href="https://zh.javascript.info/array-methods#arrayisarray">Array.isArray</a></h2><p>数组是基于对象的，不构成单独的语言类型。</p>
<p> <code>typeof</code> 不能帮助从数组中区分出普通对象，如果 <code>value</code> 是一个数组，则返回 <code>true</code>；否则返回 <code>false</code>。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="title function_">alert</span>(<span class="title class_">Array</span>.<span class="title function_">isArray</span>(&#123;&#125;)); <span class="comment">// false</span></span><br><span class="line"></span><br><span class="line"><span class="title function_">alert</span>(<span class="title class_">Array</span>.<span class="title function_">isArray</span>([])); <span class="comment">// true</span></span><br></pre></td></tr></table></figure>

<h2 id="大多数方法都支持-“thisArg”"><a href="#大多数方法都支持-“thisArg”" class="headerlink" title="大多数方法都支持 “thisArg”"></a><a target="_blank" rel="noopener" href="https://zh.javascript.info/array-methods#da-duo-shu-fang-fa-du-zhi-chi-thisarg">大多数方法都支持 “thisArg”</a></h2><p>几乎所有调用函数的数组方法 —— 比如 <code>find</code>，<code>filter</code>，<code>map</code>，除了 <code>sort</code> 是一个特例，都接受一个可选的附加参数 <code>thisArg</code>。</p>
<p><code>thisArg</code> 参数的值在 <code>func</code> 中变为 <code>this</code></p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> army = &#123;</span><br><span class="line">  <span class="attr">minAge</span>: <span class="number">18</span>,</span><br><span class="line">  <span class="attr">maxAge</span>: <span class="number">27</span>,</span><br><span class="line">  <span class="title function_">canJoin</span>(<span class="params">user</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> user.<span class="property">age</span> &gt;= <span class="variable language_">this</span>.<span class="property">minAge</span> &amp;&amp; user.<span class="property">age</span> &lt; <span class="variable language_">this</span>.<span class="property">maxAge</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> users = [</span><br><span class="line">  &#123;<span class="attr">age</span>: <span class="number">16</span>&#125;,</span><br><span class="line">  &#123;<span class="attr">age</span>: <span class="number">20</span>&#125;,</span><br><span class="line">  &#123;<span class="attr">age</span>: <span class="number">23</span>&#125;,</span><br><span class="line">  &#123;<span class="attr">age</span>: <span class="number">30</span>&#125;</span><br><span class="line">];</span><br><span class="line"></span><br><span class="line"><span class="comment">// 找到 army.canJoin 返回 true 的 user</span></span><br><span class="line"><span class="keyword">let</span> soldiers = users.<span class="title function_">filter</span>(army.<span class="property">canJoin</span>, army);</span><br><span class="line"></span><br><span class="line"><span class="title function_">alert</span>(soldiers.<span class="property">length</span>); <span class="comment">// 2</span></span><br><span class="line"><span class="title function_">alert</span>(soldiers[<span class="number">0</span>].<span class="property">age</span>); <span class="comment">// 20</span></span><br><span class="line"><span class="title function_">alert</span>(soldiers[<span class="number">1</span>].<span class="property">age</span>); <span class="comment">// 23</span></span><br></pre></td></tr></table></figure>

<p>如果在上面的示例中使用了 <code>users.filter(army.canJoin)</code>，那么 <code>army.canJoin</code> 将被作为独立函数调用，并且这时 <code>this=undefined</code>，从而会导致即时错误。</p>
<p>可以用 <code>users.filter(user =&gt; army.canJoin(user))</code> 替换对 <code>users.filter(army.canJoin, army)</code> 的调用。前者的使用频率更高</p>
<h2 id="总结-3"><a href="#总结-3" class="headerlink" title="总结"></a><a target="_blank" rel="noopener" href="https://zh.javascript.info/array-methods#zong-jie">总结</a></h2><p>数组方法备忘单：</p>
<ul>
<li>添加&#x2F;删除元素：<ul>
<li><code>push(...items)</code> —— 向尾端添加元素，</li>
<li><code>pop()</code> —— 从尾端提取一个元素，</li>
<li><code>shift()</code> —— 从首端提取一个元素，</li>
<li><code>unshift(...items)</code> —— 向首端添加元素，</li>
<li><code>splice(pos, deleteCount, ...items)</code> —— 从 <code>pos</code> 开始删除 <code>deleteCount</code> 个元素，并插入 <code>items</code>。</li>
<li><code>slice(start, end)</code> —— 创建一个新数组，将从索引 <code>start</code> 到索引 <code>end</code>（但不包括 <code>end</code>）的元素复制进去。</li>
<li><code>concat(...items)</code> —— 返回一个新数组：复制当前数组的所有元素，并向其中添加 <code>items</code>。如果 <code>items</code> 中的任意一项是一个数组，那么就取其元素。</li>
</ul>
</li>
<li>搜索元素：<ul>
<li><code>indexOf/lastIndexOf(item, pos)</code> —— 从索引 <code>pos</code> 开始搜索 <code>item</code>，搜索到则返回该项的索引，否则返回 <code>-1</code>。</li>
<li><code>includes(value)</code> —— 如果数组有 <code>value</code>，则返回 <code>true</code>，否则返回 <code>false</code>。</li>
<li><code>find/filter(func)</code> —— 通过 <code>func</code> 过滤元素，返回使 <code>func</code> 返回 <code>true</code> 的第一个值&#x2F;所有值。</li>
<li><code>findIndex</code> 和 <code>find</code> 类似，但返回索引而不是值。</li>
</ul>
</li>
<li>遍历元素：<ul>
<li><code>forEach(func)</code> —— 对每个元素都调用 <code>func</code>，不返回任何内容。</li>
</ul>
</li>
<li>转换数组：<ul>
<li><code>map(func)</code> —— 根据对每个元素调用 <code>func</code> 的结果创建一个新数组。</li>
<li><code>sort(func)</code> —— 对数组进行原位（in-place）排序，然后返回它。</li>
<li><code>reverse()</code> —— 原位（in-place）反转数组，然后返回它。</li>
<li><code>split/join</code> —— 将字符串转换为数组并返回。</li>
<li><code>reduce/reduceRight(func, initial)</code> —— 通过对每个元素调用 <code>func</code> 计算数组上的单个值，并在调用之间传递中间结果。</li>
</ul>
</li>
<li>其他：<ul>
<li><code>Array.isArray(value)</code> 检查 <code>value</code> 是否是一个数组，如果是则返回 <code>true</code>，否则返回 <code>false</code>。</li>
</ul>
</li>
</ul>
<p>请注意，<code>sort</code>，<code>reverse</code> 和 <code>splice</code> 方法修改的是数组本身。</p>
<p>这些是最常用的方法，它们覆盖 99％ 的用例。但是还有其他几个：</p>
<ul>
<li><p><a target="_blank" rel="noopener" href="https://developer.mozilla.org/zh/docs/Web/JavaScript/Reference/Global_Objects/Array/some">arr.some(fn)</a>&#x2F;<a target="_blank" rel="noopener" href="https://developer.mozilla.org/zh/docs/Web/JavaScript/Reference/Global_Objects/Array/every">arr.every(fn)</a> 检查数组。</p>
<p>与 <code>map</code> 类似，对数组的每个元素调用函数 <code>fn</code>。如果任何&#x2F;所有结果为 <code>true</code>，则返回 <code>true</code>，否则返回 <code>false</code>。</p>
<p>这两个方法的行为类似于 <code>||</code> 和 <code>&amp;&amp;</code> 运算符：如果 <code>fn</code> 返回一个真值，<code>arr.some()</code> 立即返回 <code>true</code> 并停止迭代其余数组项；如果 <code>fn</code> 返回一个假值，<code>arr.every()</code> 立即返回 <code>false</code> 并停止对其余数组项的迭代。</p>
<p>我们可以使用 <code>every</code> 来比较数组：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">arraysEqual</span>(<span class="params">arr1, arr2</span>) &#123;</span><br><span class="line">  <span class="keyword">return</span> arr1.<span class="property">length</span> === arr2.<span class="property">length</span> &amp;&amp; arr1.<span class="title function_">every</span>(<span class="function">(<span class="params">value, index</span>) =&gt;</span> value === arr2[index]);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="title function_">alert</span>( <span class="title function_">arraysEqual</span>([<span class="number">1</span>, <span class="number">2</span>], [<span class="number">1</span>, <span class="number">2</span>])); <span class="comment">// true</span></span><br></pre></td></tr></table></figure>
</li>
<li><p><a target="_blank" rel="noopener" href="https://developer.mozilla.org/zh/docs/Web/JavaScript/Reference/Global_Objects/Array/fill">arr.fill(value, start, end)</a> —— 从索引 <code>start</code> 到 <code>end</code>，用重复的 <code>value</code> 填充数组。</p>
</li>
<li><p><a target="_blank" rel="noopener" href="https://developer.mozilla.org/zh/docs/Web/JavaScript/Reference/Global_Objects/Array/copyWithin">arr.copyWithin(target, start, end)</a> —— 将从位置 <code>start</code> 到 <code>end</code> 的所有元素复制到 <strong>自身</strong> 的 <code>target</code> 位置（覆盖现有元素）。</p>
</li>
<li><p><a target="_blank" rel="noopener" href="https://developer.mozilla.org/zh/docs/Web/JavaScript/Reference/Global_Objects/Array/flat">arr.flat(depth)</a>&#x2F;<a target="_blank" rel="noopener" href="https://developer.mozilla.org/zh/docs/Web/JavaScript/Reference/Global_Objects/Array/flatMap">arr.flatMap(fn)</a> 从多维数组创建一个新的扁平数组。</p>
</li>
<li><p>[Array.of(element0[, element1[, …[, elementN]]])](<a target="_blank" rel="noopener" href="https://developer.mozilla.org/zh/docs/Web/JavaScript/Reference/Global_Objects/Array/of">https://developer.mozilla.org/zh/docs/Web/JavaScript/Reference/Global_Objects/Array/of</a>) 基于可变数量的参数创建一个新的 <code>Array</code> 实例，而不需要考虑参数的数量或类型。</p>
</li>
</ul>
<p>有关完整列表，请参阅 <a target="_blank" rel="noopener" href="https://developer.mozilla.org/zh/docs/Web/JavaScript/Reference/Global_Objects/Array">手册</a>。</p>
<h1 id="Iterable-object（可迭代对象）"><a href="#Iterable-object（可迭代对象）" class="headerlink" title="Iterable object（可迭代对象）"></a>Iterable object（可迭代对象）</h1><p><strong>可迭代（Iterable）</strong> 对象是数组的泛化。这个概念是说任何对象都可以被定制为可在 <code>for..of</code> 循环中使用的对象。</p>
<p>数组是可迭代的。但不仅仅是数组。很多其他内建对象也都是可迭代的。例如字符串也是可迭代的。</p>
<p>如果从技术上讲，对象不是数组，而是表示某物的集合（列表，集合），<code>for..of</code> 是一个能够遍历它的很好的语法。</p>
<h2 id="Symbol-iterator"><a href="#Symbol-iterator" class="headerlink" title="Symbol.iterator"></a><a target="_blank" rel="noopener" href="https://zh.javascript.info/iterable#symboliterator">Symbol.iterator</a></h2><p>为了让 <code>range</code> 对象可迭代（也就让 <code>for..of</code> 可以运行）需要为对象添加一个名为 <code>Symbol.iterator</code>的方法（一个专门用于使对象可迭代的内建 symbol）。</p>
<ol>
<li>当 <code>for..of</code> 循环启动时，它会调用这个方法（如果没找到，就会报错）。这个方法必须返回一个 <strong>迭代器（iterator）</strong> —— 一个有 <code>next</code> 方法的对象。</li>
<li>从此开始，<code>for..of</code> <strong>仅适用于这个被返回的对象</strong>。</li>
<li>当 <code>for..of</code> 循环希望取得下一个数值，它就调用这个对象的 <code>next()</code> 方法。</li>
<li><code>next()</code> 方法返回的结果的格式必须是 <code>&#123;done: Boolean, value: any&#125;</code>，当 <code>done=true</code> 时，表示循环结束，否则 <code>value</code> 是下一个值。</li>
</ol>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> range = &#123;</span><br><span class="line">  <span class="attr">from</span>: <span class="number">1</span>,</span><br><span class="line">  <span class="attr">to</span>: <span class="number">5</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 1. for..of 调用首先会调用这个：</span></span><br><span class="line">range[<span class="title class_">Symbol</span>.<span class="property">iterator</span>] = <span class="keyword">function</span>(<span class="params"></span>) &#123;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// ……它返回迭代器对象（iterator object）：</span></span><br><span class="line">  <span class="comment">// 2. 接下来，for..of 仅与下面的迭代器对象一起工作，要求它提供下一个值</span></span><br><span class="line">  <span class="keyword">return</span> &#123;</span><br><span class="line">    <span class="attr">current</span>: <span class="variable language_">this</span>.<span class="property">from</span>,</span><br><span class="line">    <span class="attr">last</span>: <span class="variable language_">this</span>.<span class="property">to</span>,</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 3. next() 在 for..of 的每一轮循环迭代中被调用</span></span><br><span class="line">    <span class="title function_">next</span>(<span class="params"></span>) &#123;</span><br><span class="line">      <span class="comment">// 4. 它将会返回 &#123;done:.., value :...&#125; 格式的对象</span></span><br><span class="line">      <span class="keyword">if</span> (<span class="variable language_">this</span>.<span class="property">current</span> &lt;= <span class="variable language_">this</span>.<span class="property">last</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> &#123; <span class="attr">done</span>: <span class="literal">false</span>, <span class="attr">value</span>: <span class="variable language_">this</span>.<span class="property">current</span>++ &#125;;</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> &#123; <span class="attr">done</span>: <span class="literal">true</span> &#125;;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 现在它可以运行了！</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> num <span class="keyword">of</span> range) &#123;</span><br><span class="line">  <span class="title function_">alert</span>(num); <span class="comment">// 1, 然后是 2, 3, 4, 5</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>可迭代对象的核心功能：关注点分离。</p>
<ul>
<li><code>range</code> 自身没有 <code>next()</code> 方法。</li>
<li>相反，是通过调用 <code>range[Symbol.iterator]()</code> 创建了另一个对象，即所谓的“迭代器”对象，并且它的 <code>next</code> 会为迭代生成值。</li>
</ul>
<p><strong>因此，迭代器对象和与其进行迭代的对象是分开的。</strong></p>
<p>可以将它们合并，并使用 <code>range</code> 自身作为迭代器来简化代码。就像这样：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> range = &#123;</span><br><span class="line">  <span class="attr">from</span>: <span class="number">1</span>,</span><br><span class="line">  <span class="attr">to</span>: <span class="number">5</span>,</span><br><span class="line"></span><br><span class="line">  [<span class="title class_">Symbol</span>.<span class="property">iterator</span>]() &#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">current</span> = <span class="variable language_">this</span>.<span class="property">from</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="variable language_">this</span>;</span><br><span class="line">  &#125;,</span><br><span class="line"></span><br><span class="line">  <span class="title function_">next</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="variable language_">this</span>.<span class="property">current</span> &lt;= <span class="variable language_">this</span>.<span class="property">to</span>) &#123;</span><br><span class="line">      <span class="keyword">return</span> &#123; <span class="attr">done</span>: <span class="literal">false</span>, <span class="attr">value</span>: <span class="variable language_">this</span>.<span class="property">current</span>++ &#125;;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="keyword">return</span> &#123; <span class="attr">done</span>: <span class="literal">true</span> &#125;;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> num <span class="keyword">of</span> range) &#123;</span><br><span class="line">  <span class="title function_">alert</span>(num); <span class="comment">// 1, 然后是 2, 3, 4, 5</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>现在 <code>range[Symbol.iterator]()</code> 返回的是 <code>range</code> 对象自身：它包括了必需的 <code>next()</code> 方法，并通过 <code>this.current</code> 记忆了当前的迭代进程。</p>
<p>但缺点是，现在不可能同时在对象上运行两个 <code>for..of</code> 循环了：它们将共享迭代状态，因为只有一个迭代器，即对象本身。但是两个并行的 <code>for..of</code> 是很罕见的，即使在异步情况下。</p>
<p><strong>无穷迭代器（iterator）</strong></p>
<p>无穷迭代器也是可能的。例如，将 <code>range</code> 设置为 <code>range.to = Infinity</code>，这时 <code>range</code> 则成为了无穷迭代器。或者我们可以创建一个可迭代对象，它生成一个无穷伪随机数序列。也是可能的。</p>
<p><code>next</code> 没有什么限制，它可以返回越来越多的值，这是正常的。</p>
<h2 id="字符串是可迭代的"><a href="#字符串是可迭代的" class="headerlink" title="字符串是可迭代的"></a><a target="_blank" rel="noopener" href="https://zh.javascript.info/iterable#zi-fu-chuan-shi-ke-die-dai-de">字符串是可迭代的</a></h2><p>数组和字符串是使用最广泛的内建可迭代对象。</p>
<p>对于一个字符串，<code>for..of</code> 遍历它的每个字符</p>
<p>对于代理对（surrogate pairs），它也能正常工作！（这里的代理对也就指的是 UTF-16 的扩展字符）</p>
<h2 id="显式调用迭代器"><a href="#显式调用迭代器" class="headerlink" title="显式调用迭代器"></a><a target="_blank" rel="noopener" href="https://zh.javascript.info/iterable#xian-shi-tiao-yong-die-dai-qi">显式调用迭代器</a></h2><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> str = <span class="string">&quot;Hello&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 和 for..of 做相同的事</span></span><br><span class="line"><span class="comment">// for (let char of str) alert(char);</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> iterator = str[<span class="title class_">Symbol</span>.<span class="property">iterator</span>]();</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">  <span class="keyword">let</span> result = iterator.<span class="title function_">next</span>();</span><br><span class="line">  <span class="keyword">if</span> (result.<span class="property">done</span>) <span class="keyword">break</span>;</span><br><span class="line">  <span class="title function_">alert</span>(result.<span class="property">value</span>); <span class="comment">// 一个接一个地输出字符</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>很少需要这样做，但是比 <code>for..of</code> 更多的控制权。例如，可以拆分迭代过程：迭代一部分，然后停止，做一些其他处理，然后再恢复迭代。</p>
<h2 id="可迭代（iterable）和类数组（array-like）"><a href="#可迭代（iterable）和类数组（array-like）" class="headerlink" title="可迭代（iterable）和类数组（array-like）"></a><a target="_blank" rel="noopener" href="https://zh.javascript.info/iterable#array-like">可迭代（iterable）和类数组（array-like）</a></h2><ul>
<li><strong>Iterable</strong> 如上所述，是实现了 <code>Symbol.iterator</code> 方法的对象。</li>
<li><strong>Array-like</strong> 是有索引和 <code>length</code> 属性的对象，所以它们看起来很像数组。</li>
</ul>
<p>可迭代对象和类数组对象通常都 <strong>不是数组</strong>，它们没有 <code>push</code> 和 <code>pop</code> 等方法。如果有一个这样的对象，并想像数组那样操作它，那就非常不方便。</p>
<h2 id="Array-from"><a href="#Array-from" class="headerlink" title="Array.from"></a><a target="_blank" rel="noopener" href="https://zh.javascript.info/iterable#arrayfrom">Array.from</a></h2><p>有一个全局方法 <a target="_blank" rel="noopener" href="https://developer.mozilla.org/zh/docs/Web/JavaScript/Reference/Global_Objects/Array/from">Array.from</a> 可以接受一个可迭代或类数组的值，并从中获取一个“真正的”数组。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> arrayLike = &#123;</span><br><span class="line">  <span class="number">0</span>: <span class="string">&quot;Hello&quot;</span>,</span><br><span class="line">  <span class="number">1</span>: <span class="string">&quot;World&quot;</span>,</span><br><span class="line">  <span class="attr">length</span>: <span class="number">2</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> arr = <span class="title class_">Array</span>.<span class="title function_">from</span>(arrayLike); <span class="comment">// (*)</span></span><br><span class="line"><span class="title function_">alert</span>(arr.<span class="title function_">pop</span>()); <span class="comment">// World（pop 方法有效）</span></span><br></pre></td></tr></table></figure>

<p><code>Array.from</code> 的完整语法允许我们提供一个可选的“映射（mapping）”函数：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="title class_">Array</span>.<span class="title function_">from</span>(obj[, mapFn, thisArg])</span><br></pre></td></tr></table></figure>

<p>可选的第二个参数 <code>mapFn</code> 可以是一个函数，该函数会在对象中的元素被添加到数组前，被应用于每个元素，此外 <code>thisArg</code> 允许为该函数设置 <code>this</code>。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> arr = <span class="title class_">Array</span>.<span class="title function_">from</span>(range, <span class="function"><span class="params">num</span> =&gt;</span> num * num);</span><br><span class="line"></span><br><span class="line"><span class="title function_">alert</span>(arr); <span class="comment">// 1,4,9,16,25</span></span><br></pre></td></tr></table></figure>

<p>用 <code>Array.from</code> 将一个字符串转换为单个字符的数组</p>
<p>可以基于 <code>Array.from</code> 创建代理感知（surrogate-aware）的<code>slice</code> 方法（也就是能够处理 UTF-16 扩展字符的 <code>slice</code> 方法）：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">slice</span>(<span class="params">str, start, end</span>) &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="title class_">Array</span>.<span class="title function_">from</span>(str).<span class="title function_">slice</span>(start, end).<span class="title function_">join</span>(<span class="string">&#x27;&#x27;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> str = <span class="string">&#x27;𝒳😂𩷶&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="title function_">alert</span>( <span class="title function_">slice</span>(str, <span class="number">1</span>, <span class="number">3</span>) ); <span class="comment">// 😂𩷶</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 原生方法不支持识别代理对（译注：UTF-16 扩展字符）</span></span><br><span class="line"><span class="title function_">alert</span>( str.<span class="title function_">slice</span>(<span class="number">1</span>, <span class="number">3</span>) ); <span class="comment">// 乱码（两个不同 UTF-16 扩展字符碎片拼接的结果）</span></span><br></pre></td></tr></table></figure>

<h2 id="总结-4"><a href="#总结-4" class="headerlink" title="总结"></a><a target="_blank" rel="noopener" href="https://zh.javascript.info/iterable#zong-jie">总结</a></h2><p>可以应用 <code>for..of</code> 的对象被称为 <strong>可迭代的</strong>。</p>
<ul>
<li>技术上来说，可迭代对象必须实现 <code>Symbol.iterator</code>方法。<ul>
<li><code>obj[Symbol.iterator]()</code> 的结果被称为 <strong>迭代器（iterator）</strong>。由它处理进一步的迭代过程。</li>
<li>一个迭代器必须有 <code>next()</code> 方法，它返回一个 <code>&#123;done: Boolean, value: any&#125;</code> 对象，这里 <code>done:true</code> 表明迭代结束，否则 <code>value</code> 就是下一个值。</li>
</ul>
</li>
<li><code>Symbol.iterator</code> 方法会被 <code>for..of</code> 自动调用，但我们也可以直接调用它。</li>
<li>内建的可迭代对象例如字符串和数组，都实现了 <code>Symbol.iterator</code>。</li>
<li>字符串迭代器能够识别代理对（surrogate pair）。（代理对也就是 UTF-16 扩展字符。）</li>
</ul>
<p>有索引属性和 <code>length</code> 属性的对象被称为 <strong>类数组对象</strong>。这种对象可能还具有其他属性和方法，但是没有数组的内建方法。</p>
<p>如果我们仔细研究一下规范 —— 就会发现大多数内建方法都假设它们需要处理的是可迭代对象或者类数组对象，而不是“真正的”数组，因为这样抽象度更高。</p>
<p><code>Array.from(obj[, mapFn, thisArg])</code> 将可迭代对象或类数组对象 <code>obj</code> 转化为真正的数组 <code>Array</code>，然后我们就可以对它应用数组的方法。可选参数 <code>mapFn</code> 和 <code>thisArg</code> 允许我们将函数应用到每个元素。</p>
<h1 id="Map-and-Set（映射和集合）"><a href="#Map-and-Set（映射和集合）" class="headerlink" title="Map and Set（映射和集合）"></a>Map and Set（映射和集合）</h1><h2 id="Map"><a href="#Map" class="headerlink" title="Map"></a><a target="_blank" rel="noopener" href="https://zh.javascript.info/map-set#map">Map</a></h2><p><a target="_blank" rel="noopener" href="https://developer.mozilla.org/zh/docs/Web/JavaScript/Reference/Global_Objects/Map">Map</a> 是一个带键的数据项的集合，就像一个 <code>Object</code> 一样。 但是它们最大的差别是 <code>Map</code> 允许任何类型的键（key）。</p>
<p>它的方法和属性如下：</p>
<ul>
<li><code>new Map()</code> —— 创建 map。</li>
<li><code>map.set(key, value)</code> —— 根据键存储值。</li>
<li><code>map.get(key)</code> —— 根据键来返回值，如果 <code>map</code> 中不存在对应的 <code>key</code>，则返回 <code>undefined</code>。</li>
<li><code>map.has(key)</code> —— 如果 <code>key</code> 存在则返回 <code>true</code>，否则返回 <code>false</code>。</li>
<li><code>map.delete(key)</code> —— 删除指定键的值。</li>
<li><code>map.clear()</code> —— 清空 map。</li>
<li><code>map.size</code> —— 返回当前元素个数。</li>
</ul>
<p><strong><code>map[key]</code> 不是使用 <code>Map</code> 的正确方式</strong></p>
<p>虽然 <code>map[key]</code> 也有效，例如我们可以设置 <code>map[key] = 2</code>，这样会将 <code>map</code> 视为 JavaScript 的 plain object，因此它暗含了所有相应的限制（仅支持 string&#x2F;symbol 键等）。</p>
<p>所以我们应该使用 <code>map</code> 方法：<code>set</code> 和 <code>get</code> 等。</p>
<p><strong>Map 还可以使用对象作为键。</strong></p>
<p>使用对象作为键是 <code>Map</code> 最值得注意和重要的功能之一。在 <code>Object</code> 中，我们则无法使用对象作为键。在 <code>Object</code> 中使用字符串作为键是可以的，但我们无法使用另一个 <code>Object</code> 作为 <code>Object</code> 中的键。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> john = &#123; <span class="attr">name</span>: <span class="string">&quot;John&quot;</span> &#125;;</span><br><span class="line"><span class="keyword">let</span> ben = &#123; <span class="attr">name</span>: <span class="string">&quot;Ben&quot;</span> &#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> visitsCountObj = &#123;&#125;; <span class="comment">// 尝试使用对象</span></span><br><span class="line"></span><br><span class="line">visitsCountObj[ben] = <span class="number">234</span>; <span class="comment">// 尝试将对象 ben 用作键</span></span><br><span class="line">visitsCountObj[john] = <span class="number">123</span>; <span class="comment">// 尝试将对象 john 用作键，但我们会发现使用对象 ben 作为键存下的值会被替换掉</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 变成这样了！</span></span><br><span class="line"><span class="title function_">alert</span>( visitsCountObj[<span class="string">&quot;[object Object]&quot;</span>] ); <span class="comment">// 123</span></span><br></pre></td></tr></table></figure>

<p>因为 <code>visitsCountObj</code> 是一个对象，它会将所有 <code>Object</code> 键例如上面的 <code>john</code> 和 <code>ben</code> 转换为字符串 <code>&quot;[object Object]&quot;</code>。</p>
<p><strong><code>Map</code> 是怎么比较键的？</strong></p>
<p><code>Map</code> 使用 <a target="_blank" rel="noopener" href="https://tc39.github.io/ecma262/#sec-samevaluezero">SameValueZero</a> 算法来比较键是否相等。它和严格等于 <code>===</code> 差不多，但区别是 <code>NaN</code> 被看成是等于 <code>NaN</code>。所以 <code>NaN</code> 也可以被用作键。</p>
<p><strong>链式调用</strong></p>
<p>每一次 <code>map.set</code> 调用都会返回 map 本身，所以可以进行“链式”调用</p>
<h2 id="Map-迭代"><a href="#Map-迭代" class="headerlink" title="Map 迭代"></a><a target="_blank" rel="noopener" href="https://zh.javascript.info/map-set#map-die-dai">Map 迭代</a></h2><p>如果要在 <code>map</code> 里使用循环，可以使用以下三个方法：</p>
<ul>
<li><code>map.keys()</code> —— 遍历并返回一个包含所有键的可迭代对象，</li>
<li><code>map.values()</code> —— 遍历并返回一个包含所有值的可迭代对象，</li>
<li><code>map.entries()</code> —— 遍历并返回一个包含所有实体 <code>[key, value]</code> 的可迭代对象，<code>for..of</code> 在默认情况下使用的就是这个。</li>
</ul>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> recipeMap = <span class="keyword">new</span> <span class="title class_">Map</span>([</span><br><span class="line">  [<span class="string">&#x27;cucumber&#x27;</span>, <span class="number">500</span>],</span><br><span class="line">  [<span class="string">&#x27;tomatoes&#x27;</span>, <span class="number">350</span>],</span><br><span class="line">  [<span class="string">&#x27;onion&#x27;</span>,    <span class="number">50</span>]</span><br><span class="line">]);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 遍历所有的键（vegetables）</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> vegetable <span class="keyword">of</span> recipeMap.<span class="title function_">keys</span>()) &#123;</span><br><span class="line">  <span class="title function_">alert</span>(vegetable); <span class="comment">// cucumber, tomatoes, onion</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 遍历所有的值（amounts）</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> amount <span class="keyword">of</span> recipeMap.<span class="title function_">values</span>()) &#123;</span><br><span class="line">  <span class="title function_">alert</span>(amount); <span class="comment">// 500, 350, 50</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 遍历所有的实体 [key, value]</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> entry <span class="keyword">of</span> recipeMap) &#123; <span class="comment">// 与 recipeMap.entries() 相同</span></span><br><span class="line">  <span class="title function_">alert</span>(entry); <span class="comment">// cucumber,500 (and so on)</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>使用插入顺序</strong></p>
<p>迭代的顺序与插入值的顺序相同。与普通的 <code>Object</code> 不同，<code>Map</code> 保留了此顺序。</p>
<p><code>Map</code> 有内建的 <code>forEach</code> 方法，与 <code>Array</code> 类似</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 对每个键值对 (key, value) 运行 forEach 函数</span></span><br><span class="line">recipeMap.<span class="title function_">forEach</span>( <span class="function">(<span class="params">value, key, map</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="title function_">alert</span>(<span class="string">`<span class="subst">$&#123;key&#125;</span>: <span class="subst">$&#123;value&#125;</span>`</span>); <span class="comment">// cucumber: 500 etc</span></span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<h2 id="Object-entries：从对象创建-Map"><a href="#Object-entries：从对象创建-Map" class="headerlink" title="Object.entries：从对象创建 Map"></a><a target="_blank" rel="noopener" href="https://zh.javascript.info/map-set#objectentries-cong-dui-xiang-chuang-jian-map">Object.entries：从对象创建 Map</a></h2><p>当创建一个 <code>Map</code> 后，我们可以传入一个带有键值对的数组（或其它可迭代对象）来进行初始化</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 键值对 [key, value] 数组</span></span><br><span class="line"><span class="keyword">let</span> map = <span class="keyword">new</span> <span class="title class_">Map</span>([</span><br><span class="line">  [<span class="string">&#x27;1&#x27;</span>,  <span class="string">&#x27;str1&#x27;</span>],</span><br><span class="line">  [<span class="number">1</span>,    <span class="string">&#x27;num1&#x27;</span>],</span><br><span class="line">  [<span class="literal">true</span>, <span class="string">&#x27;bool1&#x27;</span>]</span><br><span class="line">]);</span><br><span class="line"></span><br><span class="line"><span class="title function_">alert</span>( map.<span class="title function_">get</span>(<span class="string">&#x27;1&#x27;</span>) ); <span class="comment">// str1</span></span><br></pre></td></tr></table></figure>

<p>如果我们想从一个已有的普通对象（plain object）来创建一个 <code>Map</code>，那么我们可以使用内建方法 <a target="_blank" rel="noopener" href="https://developer.mozilla.org/zh/docs/Web/JavaScript/Reference/Global_Objects/Object/entries">Object.entries(obj)</a>，该方法返回对象的键&#x2F;值对数组，该数组格式完全按照 <code>Map</code> 所需的格式。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> obj = &#123;</span><br><span class="line">  <span class="attr">name</span>: <span class="string">&quot;John&quot;</span>,</span><br><span class="line">  <span class="attr">age</span>: <span class="number">30</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> map = <span class="keyword">new</span> <span class="title class_">Map</span>(<span class="title class_">Object</span>.<span class="title function_">entries</span>(obj));</span><br><span class="line"></span><br><span class="line"><span class="title function_">alert</span>( map.<span class="title function_">get</span>(<span class="string">&#x27;name&#x27;</span>) ); <span class="comment">// John</span></span><br></pre></td></tr></table></figure>

<p><code>Object.entries</code> 返回键&#x2F;值对数组：<code>[ [&quot;name&quot;,&quot;John&quot;], [&quot;age&quot;, 30] ]</code>。<strong>注意键是字符串。</strong></p>
<h2 id="Object-fromEntries：从-Map-创建对象"><a href="#Object-fromEntries：从-Map-创建对象" class="headerlink" title="Object.fromEntries：从 Map 创建对象"></a><a target="_blank" rel="noopener" href="https://zh.javascript.info/map-set#objectfromentries-cong-map-chuang-jian-dui-xiang">Object.fromEntries：从 Map 创建对象</a></h2><p><code>Object.fromEntries</code> 方法的作用是相反的：给定一个具有 <code>[key, value]</code> 键值对的数组，它会根据给定数组创建一个对象</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> prices = <span class="title class_">Object</span>.<span class="title function_">fromEntries</span>([</span><br><span class="line">  [<span class="string">&#x27;banana&#x27;</span>, <span class="number">1</span>],</span><br><span class="line">  [<span class="string">&#x27;orange&#x27;</span>, <span class="number">2</span>],</span><br><span class="line">  [<span class="string">&#x27;meat&#x27;</span>, <span class="number">4</span>]</span><br><span class="line">]);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 现在 prices = &#123; banana: 1, orange: 2, meat: 4 &#125;</span></span><br><span class="line"></span><br><span class="line"><span class="title function_">alert</span>(prices.<span class="property">orange</span>); <span class="comment">// 2</span></span><br></pre></td></tr></table></figure>

<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> obj = <span class="title class_">Object</span>.<span class="title function_">fromEntries</span>(map.<span class="title function_">entries</span>()); <span class="comment">// 创建一个普通对象（plain object）</span></span><br><span class="line"><span class="comment">// 或let obj = Object.fromEntries(map); // 创建一个普通对象（plain object）</span></span><br></pre></td></tr></table></figure>

<h2 id="Set"><a href="#Set" class="headerlink" title="Set"></a><a target="_blank" rel="noopener" href="https://zh.javascript.info/map-set#set">Set</a></h2><p><code>Set</code> 是一个特殊的类型集合 —— “值的集合”（没有键），它的每一个值只能出现一次。</p>
<p>它的主要方法如下：</p>
<ul>
<li><code>new Set(iterable)</code> —— 创建一个 <code>set</code>，如果提供了一个 <code>iterable</code> 对象（通常是数组），将会从数组里面复制值到 <code>set</code> 中。</li>
<li><code>set.add(value)</code> —— 添加一个值，返回 set 本身</li>
<li><code>set.delete(value)</code> —— 删除值，如果 <code>value</code> 在这个方法调用的时候存在则返回 <code>true</code> ，否则返回 <code>false</code>。</li>
<li><code>set.has(value)</code> —— 如果 <code>value</code> 在 set 中，返回 <code>true</code>，否则返回 <code>false</code>。</li>
<li><code>set.clear()</code> —— 清空 set。</li>
<li><code>set.size</code> —— 返回元素个数。</li>
</ul>
<p>重复使用同一个值调用 <code>set.add(value)</code> 并不会发生什么改变。</p>
<h2 id="Set-迭代（iteration）"><a href="#Set-迭代（iteration）" class="headerlink" title="Set 迭代（iteration）"></a><a target="_blank" rel="noopener" href="https://zh.javascript.info/map-set#set-die-dai-iteration">Set 迭代（iteration）</a></h2><p>我们可以使用 <code>for..of</code> 或 <code>forEach</code> 来遍历 Set。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">set.<span class="title function_">forEach</span>(<span class="function">(<span class="params">value, valueAgain, set</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="title function_">alert</span>(value);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<p><code>forEach</code> 的回调函数有三个参数：一个 <code>value</code>，然后是 <strong>同一个值</strong> <code>valueAgain</code>，最后是目标对象。</p>
<p><code>forEach</code> 的回调函数有三个参数，是为了与 <code>Map</code> 兼容。</p>
<p><code>Map</code> 中用于迭代的方法在 <code>Set</code> 中也同样支持：</p>
<ul>
<li><code>set.keys()</code> —— 遍历并返回一个包含所有值的可迭代对象，</li>
<li><code>set.values()</code> —— 与 <code>set.keys()</code> 作用相同，这是为了兼容 <code>Map</code>，</li>
<li><code>set.entries()</code> —— 遍历并返回一个包含所有的实体 <code>[value, value]</code> 的可迭代对象，它的存在也是为了兼容 <code>Map</code>。</li>
</ul>
<h2 id="总结-5"><a href="#总结-5" class="headerlink" title="总结"></a><a target="_blank" rel="noopener" href="https://zh.javascript.info/map-set#zong-jie">总结</a></h2><p><code>Map</code> —— 是一个带键的数据项的集合。</p>
<p>方法和属性如下：</p>
<ul>
<li><code>new Map([iterable])</code> —— 创建 map，可选择带有 <code>[key,value]</code> 对的 <code>iterable</code>（例如数组）来进行初始化。</li>
<li><code>map.set(key, value)</code> —— 根据键存储值，返回 map 自身。</li>
<li><code>map.get(key)</code> —— 根据键来返回值，如果 <code>map</code> 中不存在对应的 <code>key</code>，则返回 <code>undefined</code>。</li>
<li><code>map.has(key)</code> —— 如果 <code>key</code> 存在则返回 <code>true</code>，否则返回 <code>false</code>。</li>
<li><code>map.delete(key)</code> —— 删除指定键对应的值，如果在调用时 <code>key</code> 存在，则返回 <code>true</code>，否则返回 <code>false</code>。</li>
<li><code>map.clear()</code> —— 清空 map 。</li>
<li><code>map.size</code> —— 返回当前元素个数。</li>
</ul>
<p>与普通对象 <code>Object</code> 的不同点：</p>
<ul>
<li>任何键、对象都可以作为键。</li>
<li>有其他的便捷方法，如 <code>size</code> 属性。</li>
</ul>
<p><code>Set</code> —— 是一组唯一值的集合。</p>
<p>方法和属性：</p>
<ul>
<li><code>new Set([iterable])</code> —— 创建 set，可选择带有 <code>iterable</code>（例如数组）来进行初始化。</li>
<li><code>set.add(value)</code> —— 添加一个值（如果 <code>value</code> 存在则不做任何修改），返回 set 本身。</li>
<li><code>set.delete(value)</code> —— 删除值，如果 <code>value</code> 在这个方法调用的时候存在则返回 <code>true</code> ，否则返回 <code>false</code>。</li>
<li><code>set.has(value)</code> —— 如果 <code>value</code> 在 set 中，返回 <code>true</code>，否则返回 <code>false</code>。</li>
<li><code>set.clear()</code> —— 清空 set。</li>
<li><code>set.size</code> —— 元素的个数。</li>
</ul>
<p>在 <code>Map</code> 和 <code>Set</code> 中迭代总是按照值插入的顺序进行的，所以不能说这些集合是无序的，但是不能对元素进行重新排序，也不能直接按其编号来获取元素。</p>
<h1 id="WeakMap-and-WeakSet（弱映射和弱集合）"><a href="#WeakMap-and-WeakSet（弱映射和弱集合）" class="headerlink" title="WeakMap and WeakSet（弱映射和弱集合）"></a>WeakMap and WeakSet（弱映射和弱集合）</h1><p>通常，当对象、数组之类的数据结构在内存中时，它们的子元素，如对象的属性、数组的元素都被认为是可达的。</p>
<p>例如，如果把一个对象放入到数组中，那么只要这个数组存在，那么这个对象也就存在，即使没有其他对该对象的引用。</p>
<p>类似的，如果我们使用对象作为常规 <code>Map</code> 的键，那么当 <code>Map</code> 存在时，该对象也将存在。它会占用内存，并且不会被（垃圾回收机制）回收。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> john = &#123; <span class="attr">name</span>: <span class="string">&quot;John&quot;</span> &#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> map = <span class="keyword">new</span> <span class="title class_">Map</span>();</span><br><span class="line">map.<span class="title function_">set</span>(john, <span class="string">&quot;...&quot;</span>);</span><br><span class="line"></span><br><span class="line">john = <span class="literal">null</span>; <span class="comment">// 覆盖引用</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// john 被存储在了 map 中，</span></span><br><span class="line"><span class="comment">// 我们可以使用 map.keys() 来获取它</span></span><br></pre></td></tr></table></figure>

<p><code>WeakMap</code> 在这方面有着根本上的不同。它不会阻止垃圾回收机制对作为键的对象（key object）的回收。</p>
<h2 id="WeakMap"><a href="#WeakMap" class="headerlink" title="WeakMap"></a><a target="_blank" rel="noopener" href="https://zh.javascript.info/weakmap-weakset#weakmap">WeakMap</a></h2><p><code>WeakMap</code> 和 <code>Map</code> 的第一个不同点就是，<code>WeakMap</code> 的键必须是对象，不能是原始值</p>
<p>现在，如果在 weakMap 中使用一个对象作为键，并且没有其他对这个对象的引用 —— 该对象将会被从内存（和map）中自动清除。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> john = &#123; <span class="attr">name</span>: <span class="string">&quot;John&quot;</span> &#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> weakMap = <span class="keyword">new</span> <span class="title class_">WeakMap</span>();</span><br><span class="line">weakMap.<span class="title function_">set</span>(john, <span class="string">&quot;...&quot;</span>);</span><br><span class="line"></span><br><span class="line">john = <span class="literal">null</span>; <span class="comment">// 覆盖引用</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// john 被从内存中删除了！</span></span><br></pre></td></tr></table></figure>

<p>与上面常规的 <code>Map</code> 的例子相比，现在如果 <code>john</code> 仅仅是作为 <code>WeakMap</code> 的键而存在 —— 它将会被从 map（和内存）中自动删除。</p>
<p><code>WeakMap</code> 不支持迭代以及 <code>keys()</code>，<code>values()</code> 和 <code>entries()</code> 方法。所以没有办法获取 <code>WeakMap</code> 的所有键或值。</p>
<p><code>WeakMap</code> 只有以下的方法：</p>
<ul>
<li><code>weakMap.get(key)</code></li>
<li><code>weakMap.set(key, value)</code></li>
<li><code>weakMap.delete(key)</code></li>
<li><code>weakMap.has(key)</code></li>
</ul>
<h2 id="使用案例：额外的数据"><a href="#使用案例：额外的数据" class="headerlink" title="使用案例：额外的数据"></a><a target="_blank" rel="noopener" href="https://zh.javascript.info/weakmap-weakset#shi-yong-an-li-ewai-de-shu-ju">使用案例：额外的数据</a></h2><p><code>WeakMap</code> 的主要应用场景是 <strong>额外数据的存储</strong>。</p>
<p>假如我们正在处理一个“属于”另一个代码的一个对象，也可能是第三方库，并想存储一些与之相关的数据，那么这些数据就应该与这个对象共存亡 —— 这时候 <code>WeakMap</code> 正是我们所需要的利器。</p>
<p>我们将这些数据放到 <code>WeakMap</code> 中，并使用该对象作为这些数据的键，那么当该对象被垃圾回收机制回收后，这些数据也会被自动清除。</p>
<h2 id="使用案例：缓存"><a href="#使用案例：缓存" class="headerlink" title="使用案例：缓存"></a><a target="_blank" rel="noopener" href="https://zh.javascript.info/weakmap-weakset#shi-yong-an-li-huan-cun">使用案例：缓存</a></h2><p>另外一个常见的例子是缓存。我们可以存储（“缓存”）函数的结果，以便将来对同一个对象的调用可以重用这个结果。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 📁 cache.js</span></span><br><span class="line"><span class="keyword">let</span> cache = <span class="keyword">new</span> <span class="title class_">Map</span>();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 计算并记住结果</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">process</span>(<span class="params">obj</span>) &#123;</span><br><span class="line">  <span class="keyword">if</span> (!cache.<span class="title function_">has</span>(obj)) &#123;</span><br><span class="line">    <span class="keyword">let</span> result = <span class="comment">/* calculations of the result for */</span> obj;</span><br><span class="line"></span><br><span class="line">    cache.<span class="title function_">set</span>(obj, result);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> cache.<span class="title function_">get</span>(obj);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 现在我们在其它文件中使用 process()</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 📁 main.js</span></span><br><span class="line"><span class="keyword">let</span> obj = &#123;<span class="comment">/* 假设我们有个对象 */</span>&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> result1 = <span class="title function_">process</span>(obj); <span class="comment">// 计算完成</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// ……稍后，来自代码的另外一个地方……</span></span><br><span class="line"><span class="keyword">let</span> result2 = <span class="title function_">process</span>(obj); <span class="comment">// 取自缓存的被记忆的结果</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// ……稍后，我们不再需要这个对象时：</span></span><br><span class="line">obj = <span class="literal">null</span>;</span><br><span class="line"></span><br><span class="line"><span class="title function_">alert</span>(cache.<span class="property">size</span>); <span class="comment">// 1（啊！该对象依然在 cache 中，并占据着内存！）</span></span><br></pre></td></tr></table></figure>



<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 📁 cache.js</span></span><br><span class="line"><span class="keyword">let</span> cache = <span class="keyword">new</span> <span class="title class_">WeakMap</span>();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 计算并记结果</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">process</span>(<span class="params">obj</span>) &#123;</span><br><span class="line">  <span class="keyword">if</span> (!cache.<span class="title function_">has</span>(obj)) &#123;</span><br><span class="line">    <span class="keyword">let</span> result = <span class="comment">/* calculate the result for */</span> obj;</span><br><span class="line"></span><br><span class="line">    cache.<span class="title function_">set</span>(obj, result);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> cache.<span class="title function_">get</span>(obj);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 📁 main.js</span></span><br><span class="line"><span class="keyword">let</span> obj = &#123;<span class="comment">/* some object */</span>&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> result1 = <span class="title function_">process</span>(obj);</span><br><span class="line"><span class="keyword">let</span> result2 = <span class="title function_">process</span>(obj);</span><br><span class="line"></span><br><span class="line"><span class="comment">// ……稍后，我们不再需要这个对象时：</span></span><br><span class="line">obj = <span class="literal">null</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 无法获取 cache.size，因为它是一个 WeakMap，</span></span><br><span class="line"><span class="comment">// 要么是 0，或即将变为 0</span></span><br><span class="line"><span class="comment">// 当 obj 被垃圾回收，缓存的数据也会被清除</span></span><br></pre></td></tr></table></figure>

<h2 id="WeakSet"><a href="#WeakSet" class="headerlink" title="WeakSet"></a><a target="_blank" rel="noopener" href="https://zh.javascript.info/weakmap-weakset#weakset">WeakSet</a></h2><p><code>WeakSet</code> 的表现类似：</p>
<ul>
<li>与 <code>Set</code> 类似，但是我们只能向 <code>WeakSet</code> 添加对象（而不能是原始值）。</li>
<li>对象只有在其它某个（些）地方能被访问的时候，才能留在 <code>WeakSet</code> 中。</li>
<li>跟 <code>Set</code> 一样，<code>WeakSet</code> 支持 <code>add</code>，<code>has</code> 和 <code>delete</code> 方法，但不支持 <code>size</code> 和 <code>keys()</code>，并且不可迭代。</li>
</ul>
<p>变“弱（weak）”的同时，它也可以作为额外的存储空间。但并非针对任意数据，而是针对“是&#x2F;否”的事实。<code>WeakSet</code> 的元素可能代表着有关该对象的某些信息。</p>
<p>例如，我们可以将用户添加到 <code>WeakSet</code> 中，以追踪访问过我们网站的用户</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> visitedSet = <span class="keyword">new</span> <span class="title class_">WeakSet</span>();</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> john = &#123; <span class="attr">name</span>: <span class="string">&quot;John&quot;</span> &#125;;</span><br><span class="line"><span class="keyword">let</span> pete = &#123; <span class="attr">name</span>: <span class="string">&quot;Pete&quot;</span> &#125;;</span><br><span class="line"><span class="keyword">let</span> mary = &#123; <span class="attr">name</span>: <span class="string">&quot;Mary&quot;</span> &#125;;</span><br><span class="line"></span><br><span class="line">visitedSet.<span class="title function_">add</span>(john); <span class="comment">// John 访问了我们</span></span><br><span class="line">visitedSet.<span class="title function_">add</span>(pete); <span class="comment">// 然后是 Pete</span></span><br><span class="line">visitedSet.<span class="title function_">add</span>(john); <span class="comment">// John 再次访问</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// visitedSet 现在有两个用户了</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 检查 John 是否来访过？</span></span><br><span class="line"><span class="title function_">alert</span>(visitedSet.<span class="title function_">has</span>(john)); <span class="comment">// true</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 检查 Mary 是否来访过？</span></span><br><span class="line"><span class="title function_">alert</span>(visitedSet.<span class="title function_">has</span>(mary)); <span class="comment">// false</span></span><br><span class="line"></span><br><span class="line">john = <span class="literal">null</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// visitedSet 将被自动清理(即自动清除其中已失效的值 john)</span></span><br></pre></td></tr></table></figure>

<h2 id="总结-6"><a href="#总结-6" class="headerlink" title="总结"></a><a target="_blank" rel="noopener" href="https://zh.javascript.info/weakmap-weakset#zong-jie">总结</a></h2><p><code>WeakMap</code> 是类似于 <code>Map</code> 的集合，它仅允许对象作为键，并且一旦通过其他方式无法访问这些对象，垃圾回收便会将这些对象与其关联值一同删除。</p>
<p><code>WeakSet</code> 是类似于 <code>Set</code> 的集合，它仅存储对象，并且一旦通过其他方式无法访问这些对象，垃圾回收便会将这些对象删除。</p>
<p>它们的主要优点是它们对对象是弱引用，所以被它们引用的对象很容易地被垃圾收集器移除。</p>
<p>这是以不支持 <code>clear</code>、<code>size</code>、<code>keys</code>、<code>values</code> 等作为代价换来的……</p>
<p><code>WeakMap</code> 和 <code>WeakSet</code> 被用作“主要”对象存储之外的“辅助”数据结构。一旦将对象从主存储器中删除，如果该对象仅被用作 <code>WeakMap</code> 或 <code>WeakSet</code> 的键，那么该对象将被自动清除。</p>
<h1 id="Object-keys，values，entries"><a href="#Object-keys，values，entries" class="headerlink" title="Object.keys，values，entries"></a>Object.keys，values，entries</h1><p><code>map.keys()</code>，<code>map.values()</code> 和 <code>map.entries()</code> 方法是通用的，有一个共同的约定来将它们用于各种数据结构。如果我们创建一个我们自己的数据结构，我们也应该实现这些方法。</p>
<h2 id="Object-keys，values，entries-1"><a href="#Object-keys，values，entries-1" class="headerlink" title="Object.keys，values，entries"></a><a target="_blank" rel="noopener" href="https://zh.javascript.info/keys-values-entries#objectkeysvaluesentries">Object.keys，values，entries</a></h2><p>对于普通对象，下列这些方法是可用的：</p>
<ul>
<li><a target="_blank" rel="noopener" href="https://developer.mozilla.org/zh/docs/Web/JavaScript/Reference/Global_Objects/Object/keys">Object.keys(obj)</a> —— 返回一个包含该对象所有的键的数组。</li>
<li><a target="_blank" rel="noopener" href="https://developer.mozilla.org/zh/docs/Web/JavaScript/Reference/Global_Objects/Object/values">Object.values(obj)</a> —— 返回一个包含该对象所有的值的数组。</li>
<li><a target="_blank" rel="noopener" href="https://developer.mozilla.org/zh/docs/Web/JavaScript/Reference/Global_Objects/Object/entries">Object.entries(obj)</a> —— 返回一个包含该对象所有 [key, value] 键值对的数组。</li>
</ul>
<p>注意区别（比如说跟 map 的区别）：</p>
<table>
<thead>
<tr>
<th align="left"></th>
<th align="left">Map</th>
<th align="left">Object</th>
</tr>
</thead>
<tbody><tr>
<td align="left">调用语法</td>
<td align="left"><code>map.keys()</code></td>
<td align="left"><code>Object.keys(obj)</code>，而不是 <code>obj.keys()</code></td>
</tr>
<tr>
<td align="left">返回值</td>
<td align="left">可迭代对象</td>
<td align="left">“真正的”数组，而不只是一个可迭代对象</td>
</tr>
</tbody></table>
<p><strong>Object.keys&#x2F;values&#x2F;entries 会忽略 symbol 属性</strong></p>
<p>就像 <code>for..in</code> 循环一样，这些方法会忽略使用 <code>Symbol(...)</code> 作为键的属性。</p>
<p>通常这很方便。但是，如果我们也想要 Symbol 类型的键，那么这儿有一个单独的方法 <a target="_blank" rel="noopener" href="https://developer.mozilla.org/zh/docs/Web/JavaScript/Reference/Global_Objects/Object/getOwnPropertySymbols">Object.getOwnPropertySymbols</a>，它会返回一个只包含 Symbol 类型的键的数组。另外，还有一种方法 <a target="_blank" rel="noopener" href="https://developer.mozilla.org/zh/docs/Web/JavaScript/Reference/Global_Objects/Reflect/ownKeys">Reflect.ownKeys(obj)</a>，它会返回 <strong>所有</strong> 键。</p>
<h2 id="转换对象"><a href="#转换对象" class="headerlink" title="转换对象"></a><a target="_blank" rel="noopener" href="https://zh.javascript.info/keys-values-entries#zhuan-huan-dui-xiang">转换对象</a></h2><p>对象缺少数组存在的许多方法，例如 <code>map</code> 和 <code>filter</code> 等。</p>
<p>如果我们想应用它们，那么我们可以使用 <code>Object.entries</code>，然后使用 <code>Object.fromEntries</code>：</p>
<ol>
<li>使用 <code>Object.entries(obj)</code> 从 <code>obj</code> 获取由键&#x2F;值对组成的数组。</li>
<li>对该数组使用数组方法，例如 <code>map</code>，对这些键&#x2F;值对进行转换。</li>
<li>对结果数组使用 <code>Object.fromEntries(array)</code> 方法，将结果转回成对象。</li>
</ol>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> prices = &#123;</span><br><span class="line">	<span class="attr">banana</span>: <span class="number">1</span>,</span><br><span class="line">	<span class="attr">orange</span>: <span class="number">2</span>,</span><br><span class="line">	<span class="attr">meat</span>: <span class="number">4</span>,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> doublePrice = <span class="title class_">Object</span>.<span class="title function_">fromEntries</span>(</span><br><span class="line">	<span class="title class_">Object</span>.<span class="title function_">entries</span>(price).<span class="title function_">map</span>(<span class="function"><span class="params">entry</span> =&gt;</span> [entry[<span class="number">0</span>], entry[<span class="number">1</span>] *= <span class="number">2</span>])</span><br><span class="line">);</span><br></pre></td></tr></table></figure>

<h1 id="解构赋值"><a href="#解构赋值" class="headerlink" title="解构赋值"></a>解构赋值</h1><p><strong>解构赋值</strong> 是一种特殊的语法，它使我们可以将数组或对象“拆包”至一系列变量中。有时这样做更方便。</p>
<p>解构操作对那些具有很多参数和默认值等的函数也很奏效。</p>
<h2 id="数组解构"><a href="#数组解构" class="headerlink" title="数组解构"></a><a target="_blank" rel="noopener" href="https://zh.javascript.info/destructuring-assignment#shu-zu-jie-gou">数组解构</a></h2><p>当与 <code>split</code> 函数（或其他返回值为数组的函数）结合使用时，看起来更优雅</p>
<p><strong>“解构”并不意味着“破坏”</strong></p>
<p>这种语法被叫做“解构赋值”，是因为它“拆开”了数组或对象，将其中的各元素复制给一些变量。原来的数组或对象自身没有被修改。</p>
<p><strong>忽略使用逗号的元素</strong></p>
<p>可以通过添加额外的逗号来丢弃数组中不想要的元素：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 不需要第二个元素</span></span><br><span class="line"><span class="keyword">let</span> [firstName, , title] = [<span class="string">&quot;Julius&quot;</span>, <span class="string">&quot;Caesar&quot;</span>, <span class="string">&quot;Consul&quot;</span>, <span class="string">&quot;of the Roman Republic&quot;</span>];</span><br><span class="line"></span><br><span class="line"><span class="title function_">alert</span>( title ); <span class="comment">// Consul</span></span><br></pre></td></tr></table></figure>

<p><strong>等号右侧可以是任何可迭代对象</strong></p>
<p>可以将其与任何可迭代对象一起使用，而不仅限于数组：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> [a, b, c] = <span class="string">&quot;abc&quot;</span>; <span class="comment">// [&quot;a&quot;, &quot;b&quot;, &quot;c&quot;]</span></span><br><span class="line"><span class="keyword">let</span> [one, two, three] = <span class="keyword">new</span> <span class="title class_">Set</span>([<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]);</span><br></pre></td></tr></table></figure>

<p>这种情况下解构赋值是通过迭代右侧的值来完成工作的。这是一种用于对在 <code>=</code> 右侧的值上调用 <code>for..of</code> 并进行赋值的操作的语法糖。</p>
<p><strong>赋值给等号左侧的任何内容</strong></p>
<p>可以在等号左侧使用任何“可以被赋值的”东西。例如，一个对象的属性</p>
<p><strong>与 .entries() 方法进行循环操作</strong></p>
<p>可以将 .entries() 方法与解构语法一同使用，来遍历一个对象的“键—值”对</p>
<p><strong>交换变量值的技巧</strong></p>
<p>使用解构赋值来交换两个变量的值是一个著名的技巧</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> guest = <span class="string">&quot;Jane&quot;</span>;</span><br><span class="line"><span class="keyword">let</span> admin = <span class="string">&quot;Pete&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 让我们来交换变量的值：使得 guest = Pete，admin = Jane</span></span><br><span class="line">[guest, admin] = [admin, guest];</span><br></pre></td></tr></table></figure>

<h3 id="其余的-‘…’"><a href="#其余的-‘…’" class="headerlink" title="其余的 ‘…’"></a><a target="_blank" rel="noopener" href="https://zh.javascript.info/destructuring-assignment#qi-yu-de">其余的 ‘…’</a></h3><p>通常，如果数组比左边的列表长，那么“其余”的数组项会被省略。</p>
<p>如果还想收集其余的数组项 —— 我们可以使用三个点 <code>&quot;...&quot;</code> 来再加一个参数以获取其余数组项：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> [name1, name2, ...rest] = [<span class="string">&quot;Julius&quot;</span>, <span class="string">&quot;Caesar&quot;</span>, <span class="string">&quot;Consul&quot;</span>, <span class="string">&quot;of the Roman Republic&quot;</span>];</span><br><span class="line"></span><br><span class="line"><span class="comment">// rest 是包含从第三项开始的其余数组项的数组</span></span><br><span class="line"><span class="title function_">alert</span>(rest[<span class="number">0</span>]); <span class="comment">// Consul</span></span><br><span class="line"><span class="title function_">alert</span>(rest[<span class="number">1</span>]); <span class="comment">// of the Roman Republic</span></span><br><span class="line"><span class="title function_">alert</span>(rest.<span class="property">length</span>); <span class="comment">// 2</span></span><br></pre></td></tr></table></figure>

<h3 id="默认值"><a href="#默认值" class="headerlink" title="默认值"></a><a target="_blank" rel="noopener" href="https://zh.javascript.info/destructuring-assignment#mo-ren-zhi">默认值</a></h3><p>如果数组比左边的变量列表短，这里不会出现报错。缺少对应值的变量都会被赋 <code>undefined</code></p>
<p>如果想要一个“默认”值给未赋值的变量，我们可以使用 <code>=</code> 来提供</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 默认值</span></span><br><span class="line"><span class="keyword">let</span> [name = <span class="string">&quot;Guest&quot;</span>, surname = <span class="string">&quot;Anonymous&quot;</span>] = [<span class="string">&quot;Julius&quot;</span>];</span><br><span class="line"></span><br><span class="line"><span class="title function_">alert</span>(name);    <span class="comment">// Julius（来自数组的值）</span></span><br><span class="line"><span class="title function_">alert</span>(surname); <span class="comment">// Anonymous（默认值被使用了）</span></span><br></pre></td></tr></table></figure>

<p>默认值可以是更加复杂的表达式，甚至可以是函数调用。不过，这些表达式或函数只会在这个变量未被赋值的时候才会被计算</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 只会提示输入姓氏</span></span><br><span class="line"><span class="keyword">let</span> [name = <span class="title function_">prompt</span>(<span class="string">&#x27;name?&#x27;</span>), surname = <span class="title function_">prompt</span>(<span class="string">&#x27;surname?&#x27;</span>)] = [<span class="string">&quot;Julius&quot;</span>];</span><br><span class="line"></span><br><span class="line"><span class="title function_">alert</span>(name);    <span class="comment">// Julius（来自数组）</span></span><br><span class="line"><span class="title function_">alert</span>(surname); <span class="comment">// 你输入的值</span></span><br></pre></td></tr></table></figure>

<p><code>prompt</code> 将仅针对缺失值（<code>surname</code>）运行。</p>
<h2 id="对象解构"><a href="#对象解构" class="headerlink" title="对象解构"></a><a target="_blank" rel="noopener" href="https://zh.javascript.info/destructuring-assignment#dui-xiang-jie-gou">对象解构</a></h2><p>基本语法：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> &#123;var1, var2&#125; = &#123;<span class="attr">var1</span>:…, <span class="attr">var2</span>:…&#125;</span><br></pre></td></tr></table></figure>

<p>在等号右侧是一个已经存在的对象，想把它拆分到变量中。等号左侧包含了对象相应属性的一个类对象“模式（pattern）”。在最简单的情况下，等号左侧的就是 <code>&#123;...&#125;</code> 中的变量名列表。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> options = &#123;</span><br><span class="line">	<span class="attr">title</span>: <span class="string">&#x27;Menu&#x27;</span>,</span><br><span class="line">	<span class="attr">length</span>: <span class="number">100</span>,</span><br><span class="line">	<span class="attr">width</span>: <span class="number">200</span>,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> &#123;title, length, width&#125; = options</span><br><span class="line"></span><br><span class="line"><span class="title function_">alert</span>( title );</span><br></pre></td></tr></table></figure>

<p>属性 <code>options.title</code>、<code>options.width</code> 和 <code>options.height</code> 值被赋给了对应的变量。</p>
<p>变量的顺序并不重要，下面这个代码也是等价的：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> &#123;height, width, title&#125; = &#123; <span class="attr">title</span>: <span class="string">&quot;Menu&quot;</span>, <span class="attr">height</span>: <span class="number">200</span>, <span class="attr">width</span>: <span class="number">100</span> &#125;</span><br></pre></td></tr></table></figure>

<p>如果想把一个属性赋值给另一个名字的变量，比如把 <code>options.width</code> 属性赋值给名为 <code>w</code> 的变量，那么我们可以使用冒号来设置变量名称</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> options = &#123;</span><br><span class="line">  <span class="attr">title</span>: <span class="string">&quot;Menu&quot;</span>,</span><br><span class="line">  <span class="attr">width</span>: <span class="number">100</span>,</span><br><span class="line">  <span class="attr">height</span>: <span class="number">200</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// &#123; sourceProperty: targetVariable &#125;</span></span><br><span class="line"><span class="keyword">let</span> &#123;<span class="attr">width</span>: w, <span class="attr">height</span>: h, title&#125; = options;</span><br><span class="line"></span><br><span class="line"><span class="comment">// width -&gt; w</span></span><br><span class="line"><span class="comment">// height -&gt; h</span></span><br><span class="line"><span class="comment">// title -&gt; title</span></span><br><span class="line"></span><br><span class="line"><span class="title function_">alert</span>(title);  <span class="comment">// Menu</span></span><br><span class="line"><span class="title function_">alert</span>(w);      <span class="comment">// 100</span></span><br><span class="line"><span class="title function_">alert</span>(h);      <span class="comment">// 200</span></span><br></pre></td></tr></table></figure>

<p>冒号的语法是“从对象中什么属性的值：赋值给哪个变量”。</p>
<p>对于可能缺失的属性，我们可以使用 <code>&quot;=&quot;</code> 设置默认值</p>
<p>就像数组或函数参数一样，默认值可以是任意表达式甚至可以是函数调用。</p>
<h3 id="剩余模式（pattern）”…”"><a href="#剩余模式（pattern）”…”" class="headerlink" title="剩余模式（pattern）”…”"></a><a target="_blank" rel="noopener" href="https://zh.javascript.info/destructuring-assignment#sheng-yu-mo-shi-pattern">剩余模式（pattern）”…”</a></h3><p>可以使用剩余模式（pattern），与数组类似。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> options = &#123;</span><br><span class="line">  <span class="attr">title</span>: <span class="string">&quot;Menu&quot;</span>,</span><br><span class="line">  <span class="attr">height</span>: <span class="number">200</span>,</span><br><span class="line">  <span class="attr">width</span>: <span class="number">100</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// title = 名为 title 的属性</span></span><br><span class="line"><span class="comment">// rest = 存有剩余属性的对象</span></span><br><span class="line"><span class="keyword">let</span> &#123;title, ...rest&#125; = options;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 现在 title=&quot;Menu&quot;, rest=&#123;height: 200, width: 100&#125;</span></span><br><span class="line"><span class="title function_">alert</span>(rest.<span class="property">height</span>);  <span class="comment">// 200</span></span><br><span class="line"><span class="title function_">alert</span>(rest.<span class="property">width</span>);   <span class="comment">// 100</span></span><br></pre></td></tr></table></figure>

<p><strong>不使用 <code>let</code> 时的陷阱</strong></p>
<p>在上面的示例中，变量都是在赋值中通过正确方式声明的：<code>let &#123;…&#125; = &#123;…&#125;</code>。当然，我们也可以使用已有的变量，而不用 <code>let</code>，但这里有一个陷阱。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> title, width, height;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 这一行发生了错误</span></span><br><span class="line">&#123;title, width, height&#125; = &#123;<span class="attr">title</span>: <span class="string">&quot;Menu&quot;</span>, <span class="attr">width</span>: <span class="number">200</span>, <span class="attr">height</span>: <span class="number">100</span>&#125;;</span><br></pre></td></tr></table></figure>

<p>问题在于 JavaScript 把主代码流（即不在其他表达式中）的 <code>&#123;...&#125;</code> 当做一个代码块。</p>
<p>为了告诉 JavaScript 这不是一个代码块，我们可以把整个赋值表达式用括号 <code>(...)</code> 包起来</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">(&#123;title, width, height&#125; = &#123;<span class="attr">title</span>: <span class="string">&quot;Menu&quot;</span>, <span class="attr">width</span>: <span class="number">200</span>, <span class="attr">height</span>: <span class="number">100</span>&#125;);</span><br></pre></td></tr></table></figure>

<h2 id="嵌套解构"><a href="#嵌套解构" class="headerlink" title="嵌套解构"></a><a target="_blank" rel="noopener" href="https://zh.javascript.info/destructuring-assignment#qian-tao-jie-gou">嵌套解构</a></h2><p>如果一个对象或数组嵌套了其他的对象和数组，我们可以在等号左侧使用更复杂的模式（pattern）来提取更深层的数据。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> options = &#123;</span><br><span class="line">  <span class="attr">size</span>: &#123;</span><br><span class="line">    <span class="attr">width</span>: <span class="number">100</span>,</span><br><span class="line">    <span class="attr">height</span>: <span class="number">200</span></span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="attr">items</span>: [<span class="string">&quot;Cake&quot;</span>, <span class="string">&quot;Donut&quot;</span>],</span><br><span class="line">  <span class="attr">extra</span>: <span class="literal">true</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 为了清晰起见，解构赋值语句被写成多行的形式</span></span><br><span class="line"><span class="keyword">let</span> &#123;</span><br><span class="line">  <span class="attr">size</span>: &#123; <span class="comment">// 把 size 赋值到这里</span></span><br><span class="line">    width,</span><br><span class="line">    height</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="attr">items</span>: [item1, item2], <span class="comment">// 把 items 赋值到这里</span></span><br><span class="line">  title = <span class="string">&quot;Menu&quot;</span> <span class="comment">// 在对象中不存在（使用默认值）</span></span><br><span class="line">&#125; = options;</span><br></pre></td></tr></table></figure>

<p>注意等号右侧不存在某值时，使用默认值，语法<code>=</code>，不要用<code>:</code></p>
<p>注意，<code>size</code> 和 <code>items</code> 没有对应的变量，因为我们取的是它们的内容。</p>
<h2 id="智能函数参数"><a href="#智能函数参数" class="headerlink" title="智能函数参数"></a><a target="_blank" rel="noopener" href="https://zh.javascript.info/destructuring-assignment#zhi-neng-han-shu-can-shu">智能函数参数</a></h2><p>可以用一个对象来传递所有参数，而函数负责把这个对象解构成各个参数</p>
<p>也可以使用带有嵌套对象和冒号映射的更加复杂的解构</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> options = &#123;</span><br><span class="line">  <span class="attr">title</span>: <span class="string">&quot;My menu&quot;</span>,</span><br><span class="line">  <span class="attr">items</span>: [<span class="string">&quot;Item1&quot;</span>, <span class="string">&quot;Item2&quot;</span>]</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">showMenu</span>(<span class="params">&#123;</span></span><br><span class="line"><span class="params">  title = <span class="string">&quot;Untitled&quot;</span>,</span></span><br><span class="line"><span class="params">  width: w = <span class="number">100</span>,  // width goes to w</span></span><br><span class="line"><span class="params">  height: h = <span class="number">200</span>, // height goes to h</span></span><br><span class="line"><span class="params">  items: [item1, item2] // items first element goes to item1, second to item2</span></span><br><span class="line"><span class="params">&#125;</span>) &#123;</span><br><span class="line">  <span class="title function_">alert</span>( <span class="string">`<span class="subst">$&#123;title&#125;</span> <span class="subst">$&#123;w&#125;</span> <span class="subst">$&#123;h&#125;</span>`</span> ); <span class="comment">// My Menu 100 200</span></span><br><span class="line">  <span class="title function_">alert</span>( item1 ); <span class="comment">// Item1</span></span><br><span class="line">  <span class="title function_">alert</span>( item2 ); <span class="comment">// Item2</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="title function_">showMenu</span>(options);</span><br></pre></td></tr></table></figure>

<p>完整语法和解构赋值一样的：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span>(<span class="params">&#123;</span></span><br><span class="line"><span class="params">  incomingProperty: varName = defaultValue</span></span><br><span class="line"><span class="params">  ...</span></span><br><span class="line"><span class="params">&#125;</span>)</span><br></pre></td></tr></table></figure>

<p>对于参数对象，属性 <code>incomingProperty</code> 对应的变量是 <code>varName</code>，默认值是 <code>defaultValue</code>。</p>
<p>可以通过指定空对象 <code>&#123;&#125;</code> 为整个参数对象的默认值来解决空对象问题</p>
<p>一般解构假定了 <code>showMenu()</code> 函数确实存在参数。如果我们想让所有的参数都使用默认值，那我们应该传递一个空对象</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">showMenu</span>(<span class="params">&#123; title = <span class="string">&quot;Menu&quot;</span>, width = <span class="number">100</span>, height = <span class="number">200</span> &#125; = &#123;&#125;</span>) &#123;</span><br><span class="line">  <span class="title function_">alert</span>( <span class="string">`<span class="subst">$&#123;title&#125;</span> <span class="subst">$&#123;width&#125;</span> <span class="subst">$&#123;height&#125;</span>`</span> );</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="title function_">showMenu</span>(); <span class="comment">// Menu 100 200</span></span><br></pre></td></tr></table></figure>

<h2 id="总结-7"><a href="#总结-7" class="headerlink" title="总结"></a><a target="_blank" rel="noopener" href="https://zh.javascript.info/destructuring-assignment#zong-jie">总结</a></h2><ul>
<li><p>解构赋值可以简洁地将一个对象或数组拆开赋值到多个变量上。</p>
</li>
<li><p>解构对象的完整语法：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> &#123;prop : varName = <span class="keyword">default</span>, ...rest&#125; = object</span><br></pre></td></tr></table></figure>

<p>这表示属性 <code>prop</code> 会被赋值给变量 <code>varName</code>，如果没有这个属性的话，就会使用默认值 <code>default</code>。</p>
<p>没有对应映射的对象属性会被复制到 <code>rest</code> 对象。</p>
</li>
<li><p>解构数组的完整语法：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> [item1 = <span class="keyword">default</span>, item2, ...rest] = array</span><br></pre></td></tr></table></figure>

<p>数组的第一个元素被赋值给 <code>item1</code>，第二个元素被赋值给 <code>item2</code>，剩下的所有元素被复制到另一个数组 <code>rest</code>。</p>
</li>
<li><p>从嵌套数组&#x2F;对象中提取数据也是可以的，此时等号左侧必须和等号右侧有相同的结构。</p>
</li>
</ul>
<h1 id="日期和时间"><a href="#日期和时间" class="headerlink" title="日期和时间"></a>日期和时间</h1><p>可以使用它来存储创建&#x2F;修改时间，测量时间，或者仅用来打印当前时间。</p>
<h2 id="创建"><a href="#创建" class="headerlink" title="创建"></a><a target="_blank" rel="noopener" href="https://zh.javascript.info/date#chuang-jian">创建</a></h2><p>调用 <code>new Date()</code> 来创建一个新的 <code>Date</code> 对象。在调用时可以带有一些参数，如下所示：</p>
<ul>
<li><p><code>new Date()</code></p>
<p>  不带参数 —— 创建一个表示当前日期和时间的 <code>Date</code> 对象</p>
</li>
<li><p><code>new Date(milliseconds)</code></p>
<p>  创建一个 <code>Date</code> 对象，其时间等于 1970 年 1 月 1 日 UTC+0 之后经过的毫秒数（1&#x2F;1000 秒）。</p>
<p>  传入的整数参数代表的是自 1970-01-01 00:00:00 以来经过的毫秒数，该整数被称为 <strong>时间戳</strong>。</p>
<p>  在 01.01.1970 之前的日期带有负的时间戳</p>
</li>
<li><p><code>new Date(datestring)</code></p>
</li>
</ul>
<p>如果只有一个参数，并且是字符串，那么它会被自动解析。该算法与 <code>Date.parse</code> 所使用的算法相同</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> date = <span class="keyword">new</span> <span class="title class_">Date</span>(<span class="string">&quot;2017-01-26&quot;</span>);</span><br><span class="line"><span class="title function_">alert</span>(date);</span><br><span class="line"><span class="comment">// 未指定具体时间，所以假定时间为格林尼治标准时间（GMT）的午夜零点</span></span><br><span class="line"><span class="comment">// 并根据运行代码时的用户的时区进行调整</span></span><br><span class="line"><span class="comment">// 因此，结果可能是</span></span><br><span class="line"><span class="comment">// Thu Jan 26 2017 11:00:00 GMT+1100 (Australian Eastern Daylight Time)</span></span><br><span class="line"><span class="comment">// 或</span></span><br><span class="line"><span class="comment">// Wed Jan 25 2017 16:00:00 GMT-0800 (Pacific Standard Time)</span></span><br></pre></td></tr></table></figure>

<ul>
<li><code>new Date(year, month, date, hours, minutes, seconds, ms)</code></li>
</ul>
<p>使用当前时区中的给定组件创建日期。只有前两个参数是必须的。</p>
<ol>
<li><p><code>year</code> 应该是四位数。为了兼容性，也接受 2 位数，并将其视为 <code>19xx</code>，例如 <code>98</code> 与 <code>1998</code> 相同，但强烈建议始终使用 4 位数。</p>
</li>
<li><p><code>month</code> 计数从 <code>0</code>（一月）开始，到 <code>11</code>（十二月）结束。</p>
</li>
<li><p><code>date</code> 是当月的具体某一天，如果缺失，则为默认值 <code>1</code>。</p>
</li>
<li><p>如果 <code>hours/minutes/seconds/ms</code> 缺失，则均为默认值 <code>0</code>。</p>
</li>
</ol>
<h2 id="访问日期组件"><a href="#访问日期组件" class="headerlink" title="访问日期组件"></a><a target="_blank" rel="noopener" href="https://zh.javascript.info/date#fang-wen-ri-qi-zu-jian">访问日期组件</a></h2><p>从 <code>Date</code> 对象中访问年、月等信息有多种方式：</p>
<ul>
<li><p><a target="_blank" rel="noopener" href="https://developer.mozilla.org/zh/docs/Web/JavaScript/Reference/Global_Objects/Date/getFullYear">getFullYear()</a></p>
<p>  获取年份（4 位数）</p>
</li>
<li><p><a target="_blank" rel="noopener" href="https://developer.mozilla.org/zh/docs/Web/JavaScript/Reference/Global_Objects/Date/getMonth">getMonth()</a></p>
<p>  获取月份，<strong>从 0 到 11</strong>。</p>
</li>
<li><p><a target="_blank" rel="noopener" href="https://developer.mozilla.org/zh/docs/Web/JavaScript/Reference/Global_Objects/Date/getDate">getDate()</a></p>
<p>  获取当月的具体日期，从 1 到 31，这个方法名称可能看起来有些令人疑惑。</p>
</li>
<li><p><a target="_blank" rel="noopener" href="https://developer.mozilla.org/zh/docs/Web/JavaScript/Reference/Global_Objects/Date/getHours">getHours()</a>，<a target="_blank" rel="noopener" href="https://developer.mozilla.org/zh/docs/Web/JavaScript/Reference/Global_Objects/Date/getMinutes">getMinutes()</a>，<a target="_blank" rel="noopener" href="https://developer.mozilla.org/zh/docs/Web/JavaScript/Reference/Global_Objects/Date/getSeconds">getSeconds()</a>，<a target="_blank" rel="noopener" href="https://developer.mozilla.org/zh/docs/Web/JavaScript/Reference/Global_Objects/Date/getMilliseconds">getMilliseconds()</a></p>
<p>  获取相应的时间组件。</p>
</li>
</ul>
<p><strong>不是 <code>getYear()</code>，而是 <code>getFullYear()</code></strong></p>
<p>很多 JavaScript 引擎都实现了一个非标准化的方法 <code>getYear()</code>。不推荐使用这个方法。它有时候可能会返回 2 位的年份信息。永远不要使用它。要获取年份就使用 <code>getFullYear()</code>。</p>
<p><a target="_blank" rel="noopener" href="https://developer.mozilla.org/zh/docs/Web/JavaScript/Reference/Global_Objects/Date/getDay">getDay()</a></p>
<p>获取一周中的第几天，从 <code>0</code>（星期日）到 <code>6</code>（星期六）。第一天始终是星期日，</p>
<p><strong>以上的所有方法返回的组件都是基于当地时区的。</strong></p>
<p>有与当地时区的 UTC 对应项，它们会返回基于 UTC+0 时区的日、月、年等：<a target="_blank" rel="noopener" href="https://developer.mozilla.org/zh/docs/Web/JavaScript/Reference/Global_Objects/Date/getUTCFullYear">getUTCFullYear()</a>，<a target="_blank" rel="noopener" href="https://developer.mozilla.org/zh/docs/Web/JavaScript/Reference/Global_Objects/Date/getUTCMonth">getUTCMonth()</a>，<a target="_blank" rel="noopener" href="https://developer.mozilla.org/zh/docs/Web/JavaScript/Reference/Global_Objects/Date/getUTCDay">getUTCDay()</a>。只需要在 <code>&quot;get&quot;</code> 之后插入 <code>&quot;UTC&quot;</code> 即可。</p>
<p>以下两个没有 UTC 变体的特殊方法：</p>
<p><a target="_blank" rel="noopener" href="https://developer.mozilla.org/zh/docs/Web/JavaScript/Reference/Global_Objects/Date/getTime">getTime()</a></p>
<p>返回日期的时间戳 —— 从 1970-1-1 00:00:00 UTC+0 开始到现在所经过的毫秒数。</p>
<p><a target="_blank" rel="noopener" href="https://developer.mozilla.org/zh/docs/Web/JavaScript/Reference/Global_Objects/Date/getTimezoneOffset">getTimezoneOffset()</a></p>
<p>返回 UTC 与本地时区之间的时差，以分钟为单位</p>
<h2 id="设置日期组件"><a href="#设置日期组件" class="headerlink" title="设置日期组件"></a><a target="_blank" rel="noopener" href="https://zh.javascript.info/date#she-zhi-ri-qi-zu-jian">设置日期组件</a></h2><p>下列方法可以设置日期&#x2F;时间组件：</p>
<ul>
<li><a target="_blank" rel="noopener" href="https://developer.mozilla.org/zh/docs/Web/JavaScript/Reference/Global_Objects/Date/setFullYear"><code>setFullYear(year, [month], [date])</code></a></li>
<li><a target="_blank" rel="noopener" href="https://developer.mozilla.org/zh/docs/Web/JavaScript/Reference/Global_Objects/Date/setMonth"><code>setMonth(month, [date])</code></a></li>
<li><a target="_blank" rel="noopener" href="https://developer.mozilla.org/zh/docs/Web/JavaScript/Reference/Global_Objects/Date/setDate"><code>setDate(date)</code></a></li>
<li><a target="_blank" rel="noopener" href="https://developer.mozilla.org/zh/docs/Web/JavaScript/Reference/Global_Objects/Date/setHours"><code>setHours(hour, [min], [sec], [ms])</code></a></li>
<li><a target="_blank" rel="noopener" href="https://developer.mozilla.org/zh/docs/Web/JavaScript/Reference/Global_Objects/Date/setMinutes"><code>setMinutes(min, [sec], [ms])</code></a></li>
<li><a target="_blank" rel="noopener" href="https://developer.mozilla.org/zh/docs/Web/JavaScript/Reference/Global_Objects/Date/setSeconds"><code>setSeconds(sec, [ms])</code></a></li>
<li><a target="_blank" rel="noopener" href="https://developer.mozilla.org/zh/docs/Web/JavaScript/Reference/Global_Objects/Date/setMilliseconds"><code>setMilliseconds(ms)</code></a></li>
<li><a target="_blank" rel="noopener" href="https://developer.mozilla.org/zh/docs/Web/JavaScript/Reference/Global_Objects/Date/setTime"><code>setTime(milliseconds)</code></a>（使用自 1970-01-01 00:00:00 UTC+0 以来的毫秒数来设置整个日期）</li>
</ul>
<p>以上方法除了 <code>setTime()</code> 都有 UTC 变体</p>
<p>有些方法可以一次性设置多个组件，比如 <code>setHours</code>。未提及的组件不会被修改。</p>
<h2 id="自动校准（Autocorrection）"><a href="#自动校准（Autocorrection）" class="headerlink" title="自动校准（Autocorrection）"></a><a target="_blank" rel="noopener" href="https://zh.javascript.info/date#zi-dong-xiao-zhun-autocorrection">自动校准（Autocorrection）</a></h2><p><strong>自动校准</strong> 是 <code>Date</code> 对象的一个非常方便的特性。可以设置超范围的数值，它会自动校准。</p>
<p>超出范围的日期组件将会被自动分配。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> date = <span class="keyword">new</span> <span class="title class_">Date</span>(<span class="number">2016</span>, <span class="number">1</span>, <span class="number">28</span>);</span><br><span class="line">date.<span class="title function_">setDate</span>(date.<span class="title function_">getDate</span>() + <span class="number">2</span>);</span><br><span class="line"></span><br><span class="line"><span class="title function_">alert</span>( date ); <span class="comment">// 1 Mar 2016</span></span><br></pre></td></tr></table></figure>

<p>这个特性经常被用来获取给定时间段后的日期。</p>
<p>可以设置 0 甚至可以设置负值。</p>
<h2 id="日期转化为数字，日期差值"><a href="#日期转化为数字，日期差值" class="headerlink" title="日期转化为数字，日期差值"></a><a target="_blank" rel="noopener" href="https://zh.javascript.info/date#ri-qi-zhuan-hua-wei-shu-zi-ri-qi-cha-zhi">日期转化为数字，日期差值</a></h2><p>当 <code>Date</code> 对象被转化为数字时，得到的是对应的时间戳，与使用 <code>date.getTime()</code> 的结果相同：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> date = <span class="keyword">new</span> <span class="title class_">Date</span>();</span><br><span class="line"><span class="title function_">alert</span>(+date); <span class="comment">// 以毫秒为单位的数值，与使用 date.getTime() 的结果相同</span></span><br></pre></td></tr></table></figure>

<p>日期可以相减，相减的结果是以毫秒为单位时间差。可以用于<strong>时间测量</strong>(程序运行)</p>
<h2 id="Date-now"><a href="#Date-now" class="headerlink" title="Date.now()"></a><a target="_blank" rel="noopener" href="https://zh.javascript.info/date#datenow">Date.now()</a></h2><p>如果仅仅想要测量时间间隔，不需要 <code>Date</code> 对象。有一个特殊的方法 <code>Date.now()</code>，它会返回当前的时间戳。</p>
<p>它相当于 <code>new Date().getTime()</code>，但它不会创建中间的 <code>Date</code> 对象。因此它更快，而且不会对垃圾回收造成额外的压力。</p>
<h2 id="基准测试（Benchmarking）"><a href="#基准测试（Benchmarking）" class="headerlink" title="基准测试（Benchmarking）"></a><a target="_blank" rel="noopener" href="https://zh.javascript.info/date#ji-zhun-ce-shi-benchmarking">基准测试（Benchmarking）</a></h2><p>一个很耗 CPU 性能的函数进行可靠的基准测试（Benchmarking），这种性能测量通常称为“基准测试（benchmark）”</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">diffSubtract</span>(<span class="params">date1, date2</span>) &#123;</span><br><span class="line">  <span class="keyword">return</span> date2 - date1;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">diffGetTime</span>(<span class="params">date1, date2</span>) &#123;</span><br><span class="line">  <span class="keyword">return</span> date2.<span class="title function_">getTime</span>() - date1.<span class="title function_">getTime</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">bench</span>(<span class="params">f</span>) &#123;</span><br><span class="line">  <span class="keyword">let</span> date1 = <span class="keyword">new</span> <span class="title class_">Date</span>(<span class="number">0</span>);</span><br><span class="line">  <span class="keyword">let</span> date2 = <span class="keyword">new</span> <span class="title class_">Date</span>();</span><br><span class="line"></span><br><span class="line">  <span class="keyword">let</span> start = <span class="title class_">Date</span>.<span class="title function_">now</span>();</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; <span class="number">100000</span>; i++) <span class="title function_">f</span>(date1, date2);</span><br><span class="line">  <span class="keyword">return</span> <span class="title class_">Date</span>.<span class="title function_">now</span>() - start;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> time1 = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">let</span> time2 = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 交替运行 bench(diffSubtract) 和 bench(diffGetTime) 各 10 次</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">  time1 += <span class="title function_">bench</span>(diffSubtract);</span><br><span class="line">  time2 += <span class="title function_">bench</span>(diffGetTime);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="title function_">alert</span>( <span class="string">&#x27;Total time for diffSubtract: &#x27;</span> + time1 );</span><br><span class="line"><span class="title function_">alert</span>( <span class="string">&#x27;Total time for diffGetTime: &#x27;</span> + time2 );</span><br></pre></td></tr></table></figure>

<p>现代的 JavaScript 引擎的先进优化策略只对执行很多次的 “hot code” 有效（对于执行很少次数的代码没有必要优化）。因此，在上面的例子中，第一次执行的优化程度不高。我们可能需要增加一个预热步骤</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 在主循环中增加预热环节</span></span><br><span class="line"><span class="title function_">bench</span>(diffSubtract);</span><br><span class="line"><span class="title function_">bench</span>(diffGetTime);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 开始度量</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">  time1 += <span class="title function_">bench</span>(diffSubtract);</span><br><span class="line">  time2 += <span class="title function_">bench</span>(diffGetTime);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>进行微型基准测试时要小心</strong></p>
<p>现代的 JavaScript 引擎执行了很多优化。与正常编写的代码相比，它们可能会改变“人为编写的专用于测试的代码”的执行流程，特别是在我们对很小的代码片段进行基准测试时，例如某个运算符或内建函数的工作方式。因此，为了深入理解性能问题，请学习 JavaScript 引擎的工作原理。在那之后，你或许再也不需要进行微型基准测试了。</p>
<p><a target="_blank" rel="noopener" href="http://mrale.ph/">http://mrale.ph</a> 提供了很多 V8 引擎相关的文章。</p>
<h2 id="总结-8"><a href="#总结-8" class="headerlink" title="总结"></a><a target="_blank" rel="noopener" href="https://zh.javascript.info/date#zong-jie">总结</a></h2><ul>
<li>在 JavaScript 中，日期和时间使用 <a target="_blank" rel="noopener" href="https://developer.mozilla.org/zh/docs/Web/JavaScript/Reference/Global_Objects/Date">Date</a> 对象来表示。我们不能单独创建日期或时间，<code>Date</code> 对象总是同时创建两者。</li>
<li>月份从 0 开始计数（一月是 0）。</li>
<li>一周中的某一天 <code>getDay()</code> 同样从 0 开始计算（0 代表星期日）。</li>
<li>当设置了超出范围的组件时，<code>Date</code> 会进行自动校准。对于日&#x2F;月&#x2F;小时的加减很有用。</li>
<li>日期可以相减，得到的是以毫秒表示的两者的差值。因为当 <code>Date</code> 被转换为数字时，<code>Date</code> 对象会被转换为时间戳。</li>
<li>使用 <code>Date.now()</code> 可以更快地获取当前时间的时间戳。</li>
</ul>
<p>和其他系统不同，JavaScript 中时间戳以毫秒为单位，而不是秒。</p>
<p>有时我们需要更加精准的时间度量。JavaScript 自身并没有测量微秒的方法（百万分之一秒），但大多数运行环境会提供。例如：浏览器有 <a target="_blank" rel="noopener" href="https://developer.mozilla.org/zh/docs/Web/API/Performance/now">performance.now()</a> 方法来给出从页面加载开始的以毫秒为单位的微秒数（精确到毫秒的小数点后三位）：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="title function_">alert</span>(<span class="string">`Loading started <span class="subst">$&#123;performance.now()&#125;</span>ms ago`</span>);</span><br><span class="line"><span class="comment">// 类似于 &quot;Loading started 34731.26000000001ms ago&quot;</span></span><br><span class="line"><span class="comment">// .26 表示的是微秒（260 微秒）</span></span><br><span class="line"><span class="comment">// 小数点后超过 3 位的数字是精度错误，只有前三位数字是正确的</span></span><br></pre></td></tr></table></figure>

<p>Node.js 可以通过 <code>microtime</code> 模块或使用其他方法。从技术上讲，几乎所有的设备和环境都允许获取更高精度的时间数值，只不过不是使用 <code>Date</code> 对象。</p>
<h1 id="JSON-方法，toJSON"><a href="#JSON-方法，toJSON" class="headerlink" title="JSON 方法，toJSON"></a>JSON 方法，toJSON</h1><p>假设有一个复杂的对象，我们希望将其转换为字符串，以通过网络发送，或者只是为了在日志中输出它。</p>
<h2 id="JSON-stringify"><a href="#JSON-stringify" class="headerlink" title="JSON.stringify"></a><a target="_blank" rel="noopener" href="https://zh.javascript.info/json#jsonstringify">JSON.stringify</a></h2><p><a target="_blank" rel="noopener" href="https://en.wikipedia.org/wiki/JSON">JSON</a>（JavaScript Object Notation）是表示值和对象的通用格式。在 <a target="_blank" rel="noopener" href="https://tools.ietf.org/html/rfc4627">RFC 4627</a> 标准中有对其的描述。最初它是为 JavaScript 而创建的，但许多其他编程语言也有用于处理它的库。因此，当客户端使用 JavaScript 而服务器端是使用 Ruby&#x2F;PHP&#x2F;Java 等语言编写的时，使用 JSON 可以很容易地进行数据交换。</p>
<p>JavaScript 提供了如下方法：</p>
<ul>
<li><code>JSON.stringify</code> 将对象转换为 JSON。</li>
<li><code>JSON.parse</code> 将 JSON 转换回对象。</li>
</ul>
<p>方法 <code>JSON.stringify(student)</code> 接收对象并将其转换为字符串。</p>
<p>得到的 <code>json</code> 字符串是一个被称为 <strong>JSON 编码（JSON-encoded）</strong> 或 <strong>序列化（serialized）</strong> 或 <strong>字符串化（stringified）</strong> 或 <strong>编组化（marshalled）</strong> 的对象。</p>
<p>请注意，JSON 编码的对象与对象字面量有几个重要的区别：</p>
<ul>
<li>字符串使用双引号。JSON 中没有单引号或反引号。所以 <code>&#39;John&#39;</code> 被转换为 <code>&quot;John&quot;</code>。</li>
<li>对象属性名称也是双引号的。这是强制性的。所以 <code>age:30</code> 被转换成 <code>&quot;age&quot;:30</code>。</li>
</ul>
<p><code>JSON.stringify</code> 也可以应用于原始（primitive）数据类型。</p>
<p>JSON 支持以下数据类型：</p>
<ul>
<li>Objects <code>&#123; ... &#125;</code></li>
<li>Arrays <code>[ ... ]</code></li>
<li>Primitives：<ul>
<li>strings，</li>
<li>numbers，</li>
<li>boolean values <code>true/false</code>，</li>
<li><code>null</code>。</li>
</ul>
</li>
</ul>
<p>JSON 是语言无关的纯数据规范，因此一些特定于 JavaScript 的对象属性会被 <code>JSON.stringify</code> 跳过。</p>
<p>即：</p>
<ul>
<li>函数属性（方法）。</li>
<li>Symbol 类型的键和值。</li>
<li>存储 <code>undefined</code> 的属性。</li>
</ul>
<p>支持嵌套对象转换，并且可以自动对其进行转换。</p>
<p>重要的限制：不得有循环引用。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> room = &#123;</span><br><span class="line">  <span class="attr">number</span>: <span class="number">23</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> meetup = &#123;</span><br><span class="line">  <span class="attr">title</span>: <span class="string">&quot;Conference&quot;</span>,</span><br><span class="line">  <span class="attr">participants</span>: [<span class="string">&quot;john&quot;</span>, <span class="string">&quot;ann&quot;</span>]</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">meetup.<span class="property">place</span> = room;       <span class="comment">// meetup 引用了 room</span></span><br><span class="line">room.<span class="property">occupiedBy</span> = meetup; <span class="comment">// room 引用了 meetup</span></span><br><span class="line"></span><br><span class="line"><span class="title class_">JSON</span>.<span class="title function_">stringify</span>(meetup); <span class="comment">// Error: Converting circular structure to JSON</span></span><br></pre></td></tr></table></figure>

<h2 id="排除和转换：replacer"><a href="#排除和转换：replacer" class="headerlink" title="排除和转换：replacer"></a><a target="_blank" rel="noopener" href="https://zh.javascript.info/json#pai-chu-he-zhuan-huan-replacer">排除和转换：replacer</a></h2><p><code>JSON.stringify</code> 的完整语法是</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> json = <span class="title class_">JSON</span>.<span class="title function_">stringify</span>(value[, replacer, space])</span><br></pre></td></tr></table></figure>

<p><code>value</code></p>
<p>要编码的值。</p>
<p><code>replacer</code></p>
<p>要编码的属性数组或映射函数 <code>function(key, value)</code>。</p>
<p><code>space</code></p>
<p>用于格式化的空格数量</p>
<p>大部分情况，<code>JSON.stringify</code> 仅与第一个参数一起使用。但是，如果需要微调替换过程，比如过滤掉循环引用，可以使用 <code>JSON.stringify</code> 的第二个参数。</p>
<p>为了解决循环引用，包含除了会导致循环引用的 <code>room.occupiedBy</code> 之外的所有属性（数组）：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> room = &#123;</span><br><span class="line">  <span class="attr">number</span>: <span class="number">23</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> meetup = &#123;</span><br><span class="line">  <span class="attr">title</span>: <span class="string">&quot;Conference&quot;</span>,</span><br><span class="line">  <span class="attr">participants</span>: [&#123;<span class="attr">name</span>: <span class="string">&quot;John&quot;</span>&#125;, &#123;<span class="attr">name</span>: <span class="string">&quot;Alice&quot;</span>&#125;],</span><br><span class="line">  <span class="attr">place</span>: room <span class="comment">// meetup 引用了 room</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">room.<span class="property">occupiedBy</span> = meetup; <span class="comment">// room 引用了 meetup</span></span><br><span class="line"></span><br><span class="line"><span class="title function_">alert</span>( <span class="title class_">JSON</span>.<span class="title function_">stringify</span>(meetup, [<span class="string">&#x27;title&#x27;</span>, <span class="string">&#x27;participants&#x27;</span>, <span class="string">&#x27;place&#x27;</span>, <span class="string">&#x27;name&#x27;</span>, <span class="string">&#x27;number&#x27;</span>]) );</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">&#123;</span></span><br><span class="line"><span class="comment">  &quot;title&quot;:&quot;Conference&quot;,</span></span><br><span class="line"><span class="comment">  &quot;participants&quot;:[&#123;&quot;name&quot;:&quot;John&quot;&#125;,&#123;&quot;name&quot;:&quot;Alice&quot;&#125;],</span></span><br><span class="line"><span class="comment">  &quot;place&quot;:&#123;&quot;number&quot;:23&#125;</span></span><br><span class="line"><span class="comment">&#125;</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>

<p>可以使用一个函数代替数组作为 <code>replacer</code>。</p>
<p>该函数会为每个 <code>(key,value)</code> 对调用并返回“已替换”的值，该值将替换原有的值。如果值被跳过了，则为 <code>undefined</code>。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> room = &#123;</span><br><span class="line">  <span class="attr">number</span>: <span class="number">23</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> meetup = &#123;</span><br><span class="line">  <span class="attr">title</span>: <span class="string">&quot;Conference&quot;</span>,</span><br><span class="line">  <span class="attr">participants</span>: [&#123;<span class="attr">name</span>: <span class="string">&quot;John&quot;</span>&#125;, &#123;<span class="attr">name</span>: <span class="string">&quot;Alice&quot;</span>&#125;],</span><br><span class="line">  <span class="attr">place</span>: room <span class="comment">// meetup 引用了 room</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">room.<span class="property">occupiedBy</span> = meetup; <span class="comment">// room 引用了 meetup</span></span><br><span class="line"></span><br><span class="line"><span class="title function_">alert</span>( <span class="title class_">JSON</span>.<span class="title function_">stringify</span>(meetup, <span class="keyword">function</span> <span class="title function_">replacer</span>(<span class="params">key, value</span>) &#123;</span><br><span class="line">  <span class="title function_">alert</span>(<span class="string">`<span class="subst">$&#123;key&#125;</span>: <span class="subst">$&#123;value&#125;</span>`</span>);</span><br><span class="line">  <span class="keyword">return</span> (key == <span class="string">&#x27;occupiedBy&#x27;</span>) ? <span class="literal">undefined</span> : value;</span><br><span class="line">&#125;));</span><br><span class="line"></span><br><span class="line"><span class="comment">/* key:value pairs that come to replacer:</span></span><br><span class="line"><span class="comment">:             [object Object]</span></span><br><span class="line"><span class="comment">title:        Conference</span></span><br><span class="line"><span class="comment">participants: [object Object],[object Object]</span></span><br><span class="line"><span class="comment">0:            [object Object]</span></span><br><span class="line"><span class="comment">name:         John</span></span><br><span class="line"><span class="comment">1:            [object Object]</span></span><br><span class="line"><span class="comment">name:         Alice</span></span><br><span class="line"><span class="comment">place:        [object Object]</span></span><br><span class="line"><span class="comment">number:       23</span></span><br><span class="line"><span class="comment">occupiedBy: [object Object]</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>

<p>注意 <code>replacer</code> 函数会获取每个键&#x2F;值对，包括嵌套对象和数组项。它被递归地应用。<code>replacer</code> 中的 <code>this</code> 的值是包含当前属性的对象。</p>
<p>第一个调用很特别。它是使用特殊的“包装对象”制作的：<code>&#123;&quot;&quot;: meetup&#125;</code>。换句话说，第一个 <code>(key, value)</code> 对的键是空的，并且该值是整个目标对象。这就是上面的示例中第一行是 <code>&quot;:[object Object]&quot;</code> 的原因。</p>
<h2 id="格式化：space"><a href="#格式化：space" class="headerlink" title="格式化：space"></a><a target="_blank" rel="noopener" href="https://zh.javascript.info/json#ge-shi-hua-space">格式化：space</a></h2><p><code>JSON.stringify(value, replacer, spaces)</code> 的第三个参数是用于优化格式的空格数量。</p>
<p><code>space</code> 参数专门用于调整出更美观的输出。</p>
<h2 id="自定义-“toJSON”"><a href="#自定义-“toJSON”" class="headerlink" title="自定义 “toJSON”"></a><a target="_blank" rel="noopener" href="https://zh.javascript.info/json#zi-ding-yi-tojson">自定义 “toJSON”</a></h2><p>像 <code>toString</code> 进行字符串转换，对象也可以提供 <code>toJSON</code> 方法来进行 JSON 转换。如果可用，<code>JSON.stringify</code> 会自动调用它。</p>
<p>所有日期都有一个内建的 <code>toJSON</code> 方法来返回这种类型的字符串。</p>
<p>可以为对象 <code>room</code> 添加一个自定义的 <code>toJSON</code></p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> room = &#123;</span><br><span class="line">  <span class="attr">number</span>: <span class="number">23</span>,</span><br><span class="line">  <span class="title function_">toJSON</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="variable language_">this</span>.<span class="property">number</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p><code>toJSON</code> 既可以用于直接调用 <code>JSON.stringify(room)</code> 也可以用于当 <code>room</code> 嵌套在另一个编码对象中时。</p>
<h2 id="JSON-parse"><a href="#JSON-parse" class="headerlink" title="JSON.parse"></a><a target="_blank" rel="noopener" href="https://zh.javascript.info/json#jsonparse">JSON.parse</a></h2><p>要解码 JSON 字符串，我们需要另一个方法 <a target="_blank" rel="noopener" href="https://developer.mozilla.org/zh/docs/Web/JavaScript/Reference/Global_Objects/JSON/parse">JSON.parse</a>。</p>
<p>语法：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> value = <span class="title class_">JSON</span>.<span class="title function_">parse</span>(str, [reviver]);</span><br></pre></td></tr></table></figure>

<p><code>str</code></p>
<p>要解析的 JSON 字符串。</p>
<p><code>reviver</code></p>
<p>可选的函数 <code>function(key,value)</code>，该函数将为每个 <code>(key, value)</code> 对调用，并可以对值进行转换。</p>
<p>对于嵌套对象</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> userData = <span class="string">&#x27;&#123; &quot;name&quot;: &quot;John&quot;, &quot;age&quot;: 35, &quot;isAdmin&quot;: false, &quot;friends&quot;: [0,1,2,3] &#125;&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> user = <span class="title class_">JSON</span>.<span class="title function_">parse</span>(userData);</span><br><span class="line"></span><br><span class="line"><span class="title function_">alert</span>( user.<span class="property">friends</span>[<span class="number">1</span>] ); <span class="comment">// 1</span></span><br></pre></td></tr></table></figure>

<p>JSON 可能会非常复杂，对象和数组可以包含其他对象和数组。但是它们必须遵循相同的 JSON 格式。</p>
<p>以下是手写 JSON 时的典型错误（有时必须出于调试目的编写它）：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> json = <span class="string">`&#123;</span></span><br><span class="line"><span class="string">  name: &quot;John&quot;,                     // 错误：属性名没有双引号</span></span><br><span class="line"><span class="string">  &quot;surname&quot;: &#x27;Smith&#x27;,               // 错误：值使用的是单引号（必须使用双引号）</span></span><br><span class="line"><span class="string">  &#x27;isAdmin&#x27;: false                  // 错误：键使用的是单引号（必须使用双引号）</span></span><br><span class="line"><span class="string">  &quot;birthday&quot;: new Date(2000, 2, 3), // 错误：不允许使用 &quot;new&quot;，只能是裸值</span></span><br><span class="line"><span class="string">  &quot;friends&quot;: [0,1,2,3]              // 这个没问题</span></span><br><span class="line"><span class="string">&#125;`</span>;</span><br></pre></td></tr></table></figure>

<h2 id="使用-reviver"><a href="#使用-reviver" class="headerlink" title="使用 reviver"></a><a target="_blank" rel="noopener" href="https://zh.javascript.info/json#shi-yong-reviver">使用 reviver</a></h2><p>将 reviver 函数传递给 <code>JSON.parse</code> 作为第二个参数，设计如何返回value。该函数按照“原样”返回所有值，但是 <code>date</code> 会变成 <code>Date</code>：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> schedule = <span class="string">`&#123;</span></span><br><span class="line"><span class="string">  &quot;meetups&quot;: [</span></span><br><span class="line"><span class="string">    &#123;&quot;title&quot;:&quot;Conference&quot;,&quot;date&quot;:&quot;2017-11-30T12:00:00.000Z&quot;&#125;,</span></span><br><span class="line"><span class="string">    &#123;&quot;title&quot;:&quot;Birthday&quot;,&quot;date&quot;:&quot;2017-04-18T12:00:00.000Z&quot;&#125;</span></span><br><span class="line"><span class="string">  ]</span></span><br><span class="line"><span class="string">&#125;`</span>;</span><br><span class="line"></span><br><span class="line">schedule = <span class="title class_">JSON</span>.<span class="title function_">parse</span>(schedule, <span class="keyword">function</span>(<span class="params">key, value</span>) &#123;</span><br><span class="line">  <span class="keyword">if</span> (key == <span class="string">&#x27;date&#x27;</span>) <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Date</span>(value);</span><br><span class="line">  <span class="keyword">return</span> value;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="title function_">alert</span>( schedule.<span class="property">meetups</span>[<span class="number">1</span>].<span class="property">date</span>.<span class="title function_">getDate</span>() ); <span class="comment">// 正常运行了！</span></span><br></pre></td></tr></table></figure>

<h2 id="总结-9"><a href="#总结-9" class="headerlink" title="总结"></a><a target="_blank" rel="noopener" href="https://zh.javascript.info/json#zong-jie">总结</a></h2><ul>
<li>JSON 是一种数据格式，具有自己的独立标准和大多数编程语言的库。</li>
<li>JSON 支持 object，array，string，number，boolean 和 <code>null</code>。</li>
<li>JavaScript 提供序列化（serialize）成 JSON 的方法 <a target="_blank" rel="noopener" href="https://developer.mozilla.org/zh/docs/Web/JavaScript/Reference/Global_Objects/JSON/stringify">JSON.stringify</a> 和解析 JSON 的方法 <a target="_blank" rel="noopener" href="https://developer.mozilla.org/zh/docs/Web/JavaScript/Reference/Global_Objects/JSON/parse">JSON.parse</a>。</li>
<li>这两种方法都支持用于智能读&#x2F;写的转换函数。</li>
<li>如果一个对象具有 <code>toJSON</code>，那么它会被 <code>JSON.stringify</code> 调用。</li>
</ul>
<p>​     </p>
</article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta"><i class="fas fa-circle-user fa-fw"></i>Author: </span><span class="post-copyright-info"><a href="http://example.com">John Doe</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta"><i class="fas fa-square-arrow-up-right fa-fw"></i>Link: </span><span class="post-copyright-info"><a href="http://example.com/2024/04/11/JavaScript/%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B/">http://example.com/2024/04/11/JavaScript/%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta"><i class="fas fa-circle-exclamation fa-fw"></i>Copyright Notice: </span><span class="post-copyright-info">All articles in this blog are licensed under <a target="_blank" rel="noopener" href="https://creativecommons.org/licenses/by-nc-sa/4.0/">CC BY-NC-SA 4.0</a> unless stating additionally.</span></div></div><div class="tag_share"><div class="post-meta__tag-list"></div><div class="post_share"><div class="social-share" data-image="https://i.loli.net/2021/02/24/5O1day2nriDzjSu.png" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1.1.3/sharejs/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1.1.3/sharejs/dist/js/social-share.min.js" defer></script></div></div><nav class="pagination-post" id="pagination"><div class="prev-post pull-left"><a href="/2024/04/12/JavaScript/%E6%95%B0%E7%BB%84%E6%96%B9%E6%B3%95/" title=""><div class="cover" style="background: var(--default-bg-color)"></div><div class="pagination-info"><div class="label">Previous</div><div class="prev_info"></div></div></a></div><div class="next-post pull-right"><a href="/2024/04/06/JavaScript/JavaScript%E5%9F%BA%E7%A1%80/" title="数据类型"><div class="cover" style="background: var(--default-bg-color)"></div><div class="pagination-info"><div class="label">Next</div><div class="next_info">数据类型</div></div></a></div></nav></div><div class="aside-content" id="aside-content"><div class="card-widget card-info"><div class="is-center"><div class="avatar-img"><img src="https://i.loli.net/2021/02/24/5O1day2nriDzjSu.png" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="author-info__name">John Doe</div><div class="author-info__description"></div></div><div class="card-info-data site-data is-center"><a href="/archives/"><div class="headline">Articles</div><div class="length-num">18</div></a><a href="/tags/"><div class="headline">Tags</div><div class="length-num">0</div></a><a href="/categories/"><div class="headline">Categories</div><div class="length-num">0</div></a></div><a id="card-info-btn" target="_blank" rel="noopener" href="https://github.com/xxxxxx"><i class="fab fa-github"></i><span>Follow Me</span></a></div><div class="card-widget card-announcement"><div class="item-headline"><i class="fas fa-bullhorn fa-shake"></i><span>Announcement</span></div><div class="announcement_content">This is my Blog</div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>Contents</span><span class="toc-percentage"></span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%8E%9F%E5%A7%8B%E7%B1%BB%E5%9E%8B%E7%9A%84%E6%96%B9%E6%B3%95"><span class="toc-number">1.</span> <span class="toc-text">原始类型的方法</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E6%95%B0%E5%AD%97%E7%B1%BB%E5%9E%8B"><span class="toc-number">2.</span> <span class="toc-text">数字类型</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#toString-base"><span class="toc-number">2.1.</span> <span class="toc-text">toString(base)</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%88%8D%E5%85%A5"><span class="toc-number">2.2.</span> <span class="toc-text">舍入</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B8%8D%E7%B2%BE%E7%A1%AE%E7%9A%84%E8%AE%A1%E7%AE%97"><span class="toc-number">2.3.</span> <span class="toc-text">不精确的计算</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%B5%8B%E8%AF%95%EF%BC%9AisFinite-%E5%92%8C-isNaN"><span class="toc-number">2.4.</span> <span class="toc-text">测试：isFinite 和 isNaN</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#parseInt-%E5%92%8C-parseFloat"><span class="toc-number">2.5.</span> <span class="toc-text">parseInt 和 parseFloat</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%85%B6%E4%BB%96%E6%95%B0%E5%AD%A6%E5%87%BD%E6%95%B0"><span class="toc-number">2.6.</span> <span class="toc-text">其他数学函数</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%80%BB%E7%BB%93"><span class="toc-number">2.7.</span> <span class="toc-text">总结</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%AD%97%E7%AC%A6%E4%B8%B2"><span class="toc-number">3.</span> <span class="toc-text">字符串</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%AD%97%E7%AC%A6%E4%B8%B2%E9%95%BF%E5%BA%A6"><span class="toc-number">3.1.</span> <span class="toc-text">字符串长度</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%AE%BF%E9%97%AE%E5%AD%97%E7%AC%A6"><span class="toc-number">3.2.</span> <span class="toc-text">访问字符</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%AD%97%E7%AC%A6%E4%B8%B2%E6%98%AF%E4%B8%8D%E5%8F%AF%E5%8F%98%E7%9A%84"><span class="toc-number">3.3.</span> <span class="toc-text">字符串是不可变的</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%94%B9%E5%8F%98%E5%A4%A7%E5%B0%8F%E5%86%99"><span class="toc-number">3.4.</span> <span class="toc-text">改变大小写</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%9F%A5%E6%89%BE%E5%AD%90%E5%AD%97%E7%AC%A6%E4%B8%B2"><span class="toc-number">3.5.</span> <span class="toc-text">查找子字符串</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#str-indexOf"><span class="toc-number">3.5.1.</span> <span class="toc-text">str.indexOf</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%8C%89%E4%BD%8D%EF%BC%88bitwise%EF%BC%89NOT-%E6%8A%80%E5%B7%A7"><span class="toc-number">3.5.1.1.</span> <span class="toc-text">按位（bitwise）NOT 技巧</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#includes%EF%BC%8CstartsWith%EF%BC%8CendsWith"><span class="toc-number">3.5.2.</span> <span class="toc-text">includes，startsWith，endsWith</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%8E%B7%E5%8F%96%E5%AD%90%E5%AD%97%E7%AC%A6%E4%B8%B2"><span class="toc-number">3.6.</span> <span class="toc-text">获取子字符串</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%AF%94%E8%BE%83%E5%AD%97%E7%AC%A6%E4%B8%B2"><span class="toc-number">3.7.</span> <span class="toc-text">比较字符串</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%86%85%E9%83%A8%EF%BC%8CUnicode"><span class="toc-number">3.8.</span> <span class="toc-text">内部，Unicode</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BB%A3%E7%90%86%E5%AF%B9"><span class="toc-number">3.8.1.</span> <span class="toc-text">代理对</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%80%BB%E7%BB%93-1"><span class="toc-number">3.9.</span> <span class="toc-text">总结</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E6%95%B0%E7%BB%84"><span class="toc-number">4.</span> <span class="toc-text">数组</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%A3%B0%E6%98%8E"><span class="toc-number">4.1.</span> <span class="toc-text">声明</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BD%BF%E7%94%A8-%E2%80%9Cat%E2%80%9D-%E8%8E%B7%E5%8F%96%E6%9C%80%E5%90%8E%E4%B8%80%E4%B8%AA%E5%85%83%E7%B4%A0"><span class="toc-number">4.2.</span> <span class="toc-text">使用 “at” 获取最后一个元素</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#pop-push-shift-unshift-%E6%96%B9%E6%B3%95"><span class="toc-number">4.3.</span> <span class="toc-text">pop&#x2F;push, shift&#x2F;unshift 方法</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%86%85%E9%83%A8"><span class="toc-number">4.4.</span> <span class="toc-text">内部</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%80%A7%E8%83%BD"><span class="toc-number">4.5.</span> <span class="toc-text">性能</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%BE%AA%E7%8E%AF"><span class="toc-number">4.6.</span> <span class="toc-text">循环</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%85%B3%E4%BA%8E-%E2%80%9Clength%E2%80%9D"><span class="toc-number">4.7.</span> <span class="toc-text">关于 “length”</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#new-Array"><span class="toc-number">4.8.</span> <span class="toc-text">new Array()</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%A4%9A%E7%BB%B4%E6%95%B0%E7%BB%84"><span class="toc-number">4.9.</span> <span class="toc-text">多维数组</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#toString-NaN"><span class="toc-number">4.10.</span> <span class="toc-text">toString</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B8%8D%E8%A6%81%E4%BD%BF%E7%94%A8-%E6%AF%94%E8%BE%83%E6%95%B0%E7%BB%84"><span class="toc-number">4.11.</span> <span class="toc-text">不要使用 &#x3D;&#x3D; 比较数组</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%80%BB%E7%BB%93-2"><span class="toc-number">4.12.</span> <span class="toc-text">总结</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E6%95%B0%E7%BB%84%E6%96%B9%E6%B3%95"><span class="toc-number">5.</span> <span class="toc-text">数组方法</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#splice"><span class="toc-number">5.0.1.</span> <span class="toc-text">splice</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#slice"><span class="toc-number">5.0.2.</span> <span class="toc-text">slice</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#concat"><span class="toc-number">5.0.3.</span> <span class="toc-text">concat</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%81%8D%E5%8E%86%EF%BC%9AforEach"><span class="toc-number">5.1.</span> <span class="toc-text">遍历：forEach</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%9C%A8%E6%95%B0%E7%BB%84%E4%B8%AD%E6%90%9C%E7%B4%A2"><span class="toc-number">5.2.</span> <span class="toc-text">在数组中搜索</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#indexOf-lastIndexOf-%E5%92%8C-includes"><span class="toc-number">5.2.1.</span> <span class="toc-text">indexOf&#x2F;lastIndexOf 和 includes</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#find-%E5%92%8C-findIndex-findLastIndex"><span class="toc-number">5.2.2.</span> <span class="toc-text">find 和 findIndex&#x2F;findLastIndex</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#filter"><span class="toc-number">5.2.3.</span> <span class="toc-text">filter</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%BD%AC%E6%8D%A2%E6%95%B0%E7%BB%84"><span class="toc-number">5.3.</span> <span class="toc-text">转换数组</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#map"><span class="toc-number">5.3.1.</span> <span class="toc-text">map</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#sort-fn"><span class="toc-number">5.3.2.</span> <span class="toc-text">sort(fn)</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#reverse"><span class="toc-number">5.3.3.</span> <span class="toc-text">reverse</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#split-%E5%92%8C-join"><span class="toc-number">5.3.4.</span> <span class="toc-text">split 和 join</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#reduce-reduceRight"><span class="toc-number">5.3.5.</span> <span class="toc-text">reduce&#x2F;reduceRight</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Array-isArray"><span class="toc-number">5.4.</span> <span class="toc-text">Array.isArray</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%A4%A7%E5%A4%9A%E6%95%B0%E6%96%B9%E6%B3%95%E9%83%BD%E6%94%AF%E6%8C%81-%E2%80%9CthisArg%E2%80%9D"><span class="toc-number">5.5.</span> <span class="toc-text">大多数方法都支持 “thisArg”</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%80%BB%E7%BB%93-3"><span class="toc-number">5.6.</span> <span class="toc-text">总结</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#Iterable-object%EF%BC%88%E5%8F%AF%E8%BF%AD%E4%BB%A3%E5%AF%B9%E8%B1%A1%EF%BC%89"><span class="toc-number">6.</span> <span class="toc-text">Iterable object（可迭代对象）</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#Symbol-iterator"><span class="toc-number">6.1.</span> <span class="toc-text">Symbol.iterator</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%AD%97%E7%AC%A6%E4%B8%B2%E6%98%AF%E5%8F%AF%E8%BF%AD%E4%BB%A3%E7%9A%84"><span class="toc-number">6.2.</span> <span class="toc-text">字符串是可迭代的</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%98%BE%E5%BC%8F%E8%B0%83%E7%94%A8%E8%BF%AD%E4%BB%A3%E5%99%A8"><span class="toc-number">6.3.</span> <span class="toc-text">显式调用迭代器</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%8F%AF%E8%BF%AD%E4%BB%A3%EF%BC%88iterable%EF%BC%89%E5%92%8C%E7%B1%BB%E6%95%B0%E7%BB%84%EF%BC%88array-like%EF%BC%89"><span class="toc-number">6.4.</span> <span class="toc-text">可迭代（iterable）和类数组（array-like）</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Array-from"><span class="toc-number">6.5.</span> <span class="toc-text">Array.from</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%80%BB%E7%BB%93-4"><span class="toc-number">6.6.</span> <span class="toc-text">总结</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#Map-and-Set%EF%BC%88%E6%98%A0%E5%B0%84%E5%92%8C%E9%9B%86%E5%90%88%EF%BC%89"><span class="toc-number">7.</span> <span class="toc-text">Map and Set（映射和集合）</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#Map"><span class="toc-number">7.1.</span> <span class="toc-text">Map</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Map-%E8%BF%AD%E4%BB%A3"><span class="toc-number">7.2.</span> <span class="toc-text">Map 迭代</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Object-entries%EF%BC%9A%E4%BB%8E%E5%AF%B9%E8%B1%A1%E5%88%9B%E5%BB%BA-Map"><span class="toc-number">7.3.</span> <span class="toc-text">Object.entries：从对象创建 Map</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Object-fromEntries%EF%BC%9A%E4%BB%8E-Map-%E5%88%9B%E5%BB%BA%E5%AF%B9%E8%B1%A1"><span class="toc-number">7.4.</span> <span class="toc-text">Object.fromEntries：从 Map 创建对象</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Set"><span class="toc-number">7.5.</span> <span class="toc-text">Set</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Set-%E8%BF%AD%E4%BB%A3%EF%BC%88iteration%EF%BC%89"><span class="toc-number">7.6.</span> <span class="toc-text">Set 迭代（iteration）</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%80%BB%E7%BB%93-5"><span class="toc-number">7.7.</span> <span class="toc-text">总结</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#WeakMap-and-WeakSet%EF%BC%88%E5%BC%B1%E6%98%A0%E5%B0%84%E5%92%8C%E5%BC%B1%E9%9B%86%E5%90%88%EF%BC%89"><span class="toc-number">8.</span> <span class="toc-text">WeakMap and WeakSet（弱映射和弱集合）</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#WeakMap"><span class="toc-number">8.1.</span> <span class="toc-text">WeakMap</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BD%BF%E7%94%A8%E6%A1%88%E4%BE%8B%EF%BC%9A%E9%A2%9D%E5%A4%96%E7%9A%84%E6%95%B0%E6%8D%AE"><span class="toc-number">8.2.</span> <span class="toc-text">使用案例：额外的数据</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BD%BF%E7%94%A8%E6%A1%88%E4%BE%8B%EF%BC%9A%E7%BC%93%E5%AD%98"><span class="toc-number">8.3.</span> <span class="toc-text">使用案例：缓存</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#WeakSet"><span class="toc-number">8.4.</span> <span class="toc-text">WeakSet</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%80%BB%E7%BB%93-6"><span class="toc-number">8.5.</span> <span class="toc-text">总结</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#Object-keys%EF%BC%8Cvalues%EF%BC%8Centries"><span class="toc-number">9.</span> <span class="toc-text">Object.keys，values，entries</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#Object-keys%EF%BC%8Cvalues%EF%BC%8Centries-1"><span class="toc-number">9.1.</span> <span class="toc-text">Object.keys，values，entries</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%BD%AC%E6%8D%A2%E5%AF%B9%E8%B1%A1"><span class="toc-number">9.2.</span> <span class="toc-text">转换对象</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E8%A7%A3%E6%9E%84%E8%B5%8B%E5%80%BC"><span class="toc-number">10.</span> <span class="toc-text">解构赋值</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%95%B0%E7%BB%84%E8%A7%A3%E6%9E%84"><span class="toc-number">10.1.</span> <span class="toc-text">数组解构</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%85%B6%E4%BD%99%E7%9A%84-%E2%80%98%E2%80%A6%E2%80%99"><span class="toc-number">10.1.1.</span> <span class="toc-text">其余的 ‘…’</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%BB%98%E8%AE%A4%E5%80%BC"><span class="toc-number">10.1.2.</span> <span class="toc-text">默认值</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%AF%B9%E8%B1%A1%E8%A7%A3%E6%9E%84"><span class="toc-number">10.2.</span> <span class="toc-text">对象解构</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%89%A9%E4%BD%99%E6%A8%A1%E5%BC%8F%EF%BC%88pattern%EF%BC%89%E2%80%9D%E2%80%A6%E2%80%9D"><span class="toc-number">10.2.1.</span> <span class="toc-text">剩余模式（pattern）”…”</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%B5%8C%E5%A5%97%E8%A7%A3%E6%9E%84"><span class="toc-number">10.3.</span> <span class="toc-text">嵌套解构</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%99%BA%E8%83%BD%E5%87%BD%E6%95%B0%E5%8F%82%E6%95%B0"><span class="toc-number">10.4.</span> <span class="toc-text">智能函数参数</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%80%BB%E7%BB%93-7"><span class="toc-number">10.5.</span> <span class="toc-text">总结</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E6%97%A5%E6%9C%9F%E5%92%8C%E6%97%B6%E9%97%B4"><span class="toc-number">11.</span> <span class="toc-text">日期和时间</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%88%9B%E5%BB%BA"><span class="toc-number">11.1.</span> <span class="toc-text">创建</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%AE%BF%E9%97%AE%E6%97%A5%E6%9C%9F%E7%BB%84%E4%BB%B6"><span class="toc-number">11.2.</span> <span class="toc-text">访问日期组件</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%AE%BE%E7%BD%AE%E6%97%A5%E6%9C%9F%E7%BB%84%E4%BB%B6"><span class="toc-number">11.3.</span> <span class="toc-text">设置日期组件</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%87%AA%E5%8A%A8%E6%A0%A1%E5%87%86%EF%BC%88Autocorrection%EF%BC%89"><span class="toc-number">11.4.</span> <span class="toc-text">自动校准（Autocorrection）</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%97%A5%E6%9C%9F%E8%BD%AC%E5%8C%96%E4%B8%BA%E6%95%B0%E5%AD%97%EF%BC%8C%E6%97%A5%E6%9C%9F%E5%B7%AE%E5%80%BC"><span class="toc-number">11.5.</span> <span class="toc-text">日期转化为数字，日期差值</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Date-now"><span class="toc-number">11.6.</span> <span class="toc-text">Date.now()</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%9F%BA%E5%87%86%E6%B5%8B%E8%AF%95%EF%BC%88Benchmarking%EF%BC%89"><span class="toc-number">11.7.</span> <span class="toc-text">基准测试（Benchmarking）</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%80%BB%E7%BB%93-8"><span class="toc-number">11.8.</span> <span class="toc-text">总结</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#JSON-%E6%96%B9%E6%B3%95%EF%BC%8CtoJSON"><span class="toc-number">12.</span> <span class="toc-text">JSON 方法，toJSON</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#JSON-stringify"><span class="toc-number">12.1.</span> <span class="toc-text">JSON.stringify</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%8E%92%E9%99%A4%E5%92%8C%E8%BD%AC%E6%8D%A2%EF%BC%9Areplacer"><span class="toc-number">12.2.</span> <span class="toc-text">排除和转换：replacer</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%A0%BC%E5%BC%8F%E5%8C%96%EF%BC%9Aspace"><span class="toc-number">12.3.</span> <span class="toc-text">格式化：space</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%87%AA%E5%AE%9A%E4%B9%89-%E2%80%9CtoJSON%E2%80%9D"><span class="toc-number">12.4.</span> <span class="toc-text">自定义 “toJSON”</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#JSON-parse"><span class="toc-number">12.5.</span> <span class="toc-text">JSON.parse</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BD%BF%E7%94%A8-reviver"><span class="toc-number">12.6.</span> <span class="toc-text">使用 reviver</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%80%BB%E7%BB%93-9"><span class="toc-number">12.7.</span> <span class="toc-text">总结</span></a></li></ol></li></ol></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="fas fa-history"></i><span>Recent Post</span></div><div class="aside-list"><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2024/04/21/hello-world/" title="Hello World">Hello World</a><time datetime="2024-04-21T14:30:16.023Z" title="Created 2024-04-21 22:30:16">2024-04-21</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2024/04/18/JavaScript/Promise%EF%BC%8Casyncawait/%E4%BD%BF%E7%94%A8%20promise%20%E8%BF%9B%E8%A1%8C%E9%94%99%E8%AF%AF%E5%A4%84%E7%90%86/" title="Untitled">Untitled</a><time datetime="2024-04-18T15:22:46.227Z" title="Created 2024-04-18 23:22:46">2024-04-18</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2024/04/18/JavaScript/Promise%EF%BC%8Casyncawait/Promise/" title="Untitled">Untitled</a><time datetime="2024-04-18T13:07:40.381Z" title="Created 2024-04-18 21:07:40">2024-04-18</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2024/04/18/JavaScript/Promise%EF%BC%8Casyncawait/Promise%E9%93%BE/" title="Untitled">Untitled</a><time datetime="2024-04-18T10:59:00.524Z" title="Created 2024-04-18 18:59:00">2024-04-18</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2024/04/16/JavaScript/%E5%87%BD%E6%95%B0%E8%BF%9B%E9%98%B6/%E5%87%BD%E6%95%B0%E5%AF%B9%E8%B1%A1/" title="Untitled">Untitled</a><time datetime="2024-04-16T15:53:50.035Z" title="Created 2024-04-16 23:53:50">2024-04-16</time></div></div></div></div></div></div></main><footer id="footer"><div id="footer-wrap"><div class="copyright">&copy;2020 - 2024 By John Doe</div><div class="framework-info"><span>Framework </span><a target="_blank" rel="noopener" href="https://hexo.io">Hexo</a><span class="footer-separator">|</span><span>Theme </span><a target="_blank" rel="noopener" href="https://github.com/jerryc127/hexo-theme-butterfly">Butterfly</a></div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="Read Mode"><i class="fas fa-book-open"></i></button><button id="darkmode" type="button" title="Toggle Between Light And Dark Mode"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="Toggle between Single-column and Double-column"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside-config" type="button" title="Setting"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="Table Of Contents"><i class="fas fa-list-ul"></i></button><button id="go-up" type="button" title="Back To Top"><span class="scroll-percent"></span><i class="fas fa-arrow-up"></i></button></div></div><div><script src="/js/utils.js?v=4.13.0"></script><script src="/js/main.js?v=4.13.0"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/ui@5.0.33/dist/fancybox/fancybox.umd.min.js"></script><div class="js-pjax"></div><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script></div></body></html>